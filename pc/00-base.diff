diff --git a/content/html/content/public/nsHTMLCanvasElement.h b/content/html/content/public/nsHTMLCanvasElement.h
--- a/content/html/content/public/nsHTMLCanvasElement.h
+++ b/content/html/content/public/nsHTMLCanvasElement.h
@@ -200,6 +200,10 @@
                             nsICanvasRenderingContextInternal **aContext);
 
   nsString mCurrentContextId;
+
+  bool mIsReadyToPrint;
+
+  nsCOMPtr<nsIPrintCallback> mPrintCallback;
   nsCOMPtr<nsICanvasRenderingContextInternal> mCurrentContext;
   
 public:
@@ -208,6 +212,12 @@
   // We also transitively set it when script paints a canvas which
   // is itself write-only.
   bool                     mWriteOnly;
+
+  bool mIsPrintCanvas;
+  bool mIsPrintPreview;
+
+  bool HandlePrintCallback();
+
 };
 
 #endif /* nsHTMLCanvasElement_h__ */
diff --git a/content/html/content/src/nsHTMLCanvasElement.cpp b/content/html/content/src/nsHTMLCanvasElement.cpp
--- a/content/html/content/src/nsHTMLCanvasElement.cpp
+++ b/content/html/content/src/nsHTMLCanvasElement.cpp
@@ -76,12 +76,15 @@
 }
 
 nsHTMLCanvasElement::nsHTMLCanvasElement(already_AddRefed<nsINodeInfo> aNodeInfo)
-  : nsGenericHTMLElement(aNodeInfo), mWriteOnly(false)
+  : nsGenericHTMLElement(aNodeInfo), mIsReadyToPrint(false), mWriteOnly(false),
+    mIsPrintCanvas(false), mIsPrintPreview(false)
 {
 }
 
 nsHTMLCanvasElement::~nsHTMLCanvasElement()
 {
+  mPrintCallback = NULL;
+  mCurrentContext = NULL;
 }
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(nsHTMLCanvasElement)
@@ -152,6 +155,19 @@
   return rv;
 }
 
+bool
+nsHTMLCanvasElement::HandlePrintCallback()
+{
+  if (!mIsPrintCanvas)
+    return true;
+
+  if (!mIsReadyToPrint) {
+    mIsReadyToPrint = true;
+    mPrintCallback->Render(mCurrentContext);
+  }
+  return true;
+}
+
 nsresult
 nsHTMLCanvasElement::CopyInnerTo(nsGenericElement* aDest) const
 {
@@ -159,11 +190,23 @@
   NS_ENSURE_SUCCESS(rv, rv);
   if (aDest->OwnerDoc()->IsStaticDocument()) {
     nsHTMLCanvasElement* dest = static_cast<nsHTMLCanvasElement*>(aDest);
+    nsHTMLCanvasElement* self = const_cast<nsHTMLCanvasElement*>(this);
+
+    // By default, we assume this canvas will be displayed in PrintPreview.
+    dest->mIsPrintPreview = true;
+    dest->mPrintCallback = self->mPrintCallback;
+
+    // Mark the canvas to be a "PrintCanvas" in case there is a special
+    // rendering callback for printing.
+    if (dest->mPrintCallback) {
+      dest->mIsPrintCanvas = true;
+    }
+
     nsCOMPtr<nsISupports> cxt;
     dest->GetContext(NS_LITERAL_STRING("2d"), JSVAL_VOID, getter_AddRefs(cxt));
     nsCOMPtr<nsIDOMCanvasRenderingContext2D> context2d = do_QueryInterface(cxt);
     if (context2d) {
-      context2d->DrawImage(const_cast<nsHTMLCanvasElement*>(this),
+      context2d->DrawImage(self,
                            0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0);
     }
   }
@@ -247,6 +290,30 @@
   return asyncCallback->OnInputStreamReady(asyncData);
 }
 
+NS_IMETHODIMP
+nsHTMLCanvasElement::SetMozPrintCallback(nsIPrintCallback *aCallback)
+{
+  mPrintCallback = aCallback;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsHTMLCanvasElement::GetMozPrintCallback(nsIPrintCallback** aCallback)
+{
+  return NS_OK;
+}
+/*
+NS_IMETHODIMP
+nsHTMLCanvasElement::SetMozPrintCallback(JSContext *cx, const jsval& callback)
+{
+  // Check that
+  if (JSVAL_IS_OBJECT(callback) && !JSVAL_IS_NULL(callback)) {
+    mPrintCallback = JSVAL_TO_OBJECT(callback);
+    NS_HOLD_JS_OBJECTS(this, mPrintCallback);
+  }
+}
+*/
+
 nsresult
 nsHTMLCanvasElement::ExtractData(const nsAString& aType,
                                  const nsAString& aOptions,
diff --git a/dom/interfaces/html/nsIDOMHTMLCanvasElement.idl b/dom/interfaces/html/nsIDOMHTMLCanvasElement.idl
--- a/dom/interfaces/html/nsIDOMHTMLCanvasElement.idl
+++ b/dom/interfaces/html/nsIDOMHTMLCanvasElement.idl
@@ -56,6 +56,11 @@
 interface nsIVariant;
 interface nsIInputStreamCallback;
 
+[scriptable, function, uuid(8d5fb8a0-7782-11e1-b0c4-0800200c9a66)]
+interface nsIPrintCallback : nsISupports {
+  void render(in nsISupports ctx);
+};
+
 [scriptable, uuid(5929542B-C68E-48AB-84F9-D9642DA39720)]
 interface nsIDOMHTMLCanvasElement : nsIDOMHTMLElement
 {
@@ -88,5 +93,7 @@
   // stream in the desired image format.
   void mozFetchAsStream(in nsIInputStreamCallback callback,
                                         [optional] in DOMString type);
+
+  attribute nsIPrintCallback mozPrintCallback;
 };
 
diff --git a/layout/generic/nsHTMLCanvasFrame.cpp b/layout/generic/nsHTMLCanvasFrame.cpp
--- a/layout/generic/nsHTMLCanvasFrame.cpp
+++ b/layout/generic/nsHTMLCanvasFrame.cpp
@@ -294,6 +294,9 @@
   nsHTMLCanvasElement* element = static_cast<nsHTMLCanvasElement*>(GetContent());
   nsIntSize canvasSize = GetCanvasSize();
 
+  if (!element->HandlePrintCallback())
+    return nsnull;
+
   if (canvasSize.width <= 0 || canvasSize.height <= 0 || area.IsEmpty())
     return nsnull;
 
diff --git a/layout/generic/nsSimplePageSequence.cpp b/layout/generic/nsSimplePageSequence.cpp
--- a/layout/generic/nsSimplePageSequence.cpp
+++ b/layout/generic/nsSimplePageSequence.cpp
@@ -50,6 +50,8 @@
 #include "nsContentUtils.h"
 #include "nsDisplayList.h"
 #include "mozilla/Preferences.h"
+#include "nsHTMLCanvasFrame.h"
+#include "nsHTMLCanvasElement.h"
 
 // DateTime Includes
 #include "nsDateTimeFormatCID.h"
@@ -519,6 +521,38 @@
   return rv;
 }
 
+void GetCanvasElementsInFrame(nsIFrame* aFrame, nsTArray<nsRefPtr<nsHTMLCanvasElement> >* aArr)
+{
+
+  for (nsIFrame::ChildListIterator childLists(aFrame);
+    !childLists.IsDone(); childLists.Next()) {
+
+    nsFrameList children = childLists.CurrentList();
+    for (nsFrameList::Enumerator e(children); !e.AtEnd(); e.Next()) {
+      nsIFrame* child = e.get();
+
+      // Check if child is a nsHTMLCanvasFrame.
+      nsHTMLCanvasFrame *canvasFrame = do_QueryFrame(child);
+
+      // If there is a canvasFrame, try to get actual canvas element.
+      if (canvasFrame) {
+        nsHTMLCanvasElement *canvas =
+          nsHTMLCanvasElement::FromContent(canvasFrame->GetContent());
+          // CanvasElementFromContent(canvasFrame->GetContent());
+
+        if (canvas && canvas->mIsPrintCanvas) {
+          aArr->AppendElement(canvas);
+          continue;
+        }
+      }
+      // The current child is not a nsHTMLCanvasFrame OR it is but there is
+      // no nsHTMLCanvasElement on it. Check if children of `child` might
+      // contain a nsHTMLCanvasElement.
+      GetCanvasElementsInFrame(child, aArr);
+    }
+  }
+}
+
 NS_IMETHODIMP
 nsSimplePageSequenceFrame::PrintNextPage()
 {
@@ -634,10 +668,51 @@
       nsRect drawingRect(nsPoint(0, 0),
                          mCurrentPageFrame->GetSize());
       nsRegion drawingRegion(drawingRect);
+
+
+      // Replace the underlaying context off all canvas that are "printCanvas".
+      nsRefPtr<gfxASurface> renderingSurface =
+          renderingContext->ThebesContext()->CurrentSurface();
+
+      nsTArray<nsRefPtr<nsHTMLCanvasElement> > canvasList;
+      GetCanvasElementsInFrame(mCurrentPageFrame, &canvasList);
+      for (PRInt32 i = canvasList.Length() - 1; i >= 0 ; i--) {
+        nsHTMLCanvasElement *canvas = canvasList[i];
+        nsIntSize size = canvas->GetSize();
+
+        nsRefPtr<gfxASurface> printSurface = renderingSurface->
+           CreateSimilarSurface(
+             gfxASurface::CONTENT_COLOR_ALPHA,
+             size
+           );
+
+        nsICanvasRenderingContextInternal *ctx = canvas->GetContextAtIndex(0);
+
+        if (!ctx)
+          continue;
+
+        // Initialize the context with the new printSurface.
+        ctx->InitializeWithSurface(NULL, printSurface, size.width, size.height);
+
+        // Only specify here, that this canvas won't be printed to preview.
+        // The actuall drawing is done once the nsHTMLCanvasFrame::BuildLayer
+        // function calls the canvas->HandlePrintCallback();
+        canvas->mIsPrintPreview = false;
+      }
+
       nsLayoutUtils::PaintFrame(renderingContext, mCurrentPageFrame,
                                 drawingRegion, NS_RGBA(0,0,0,0),
                                 nsLayoutUtils::PAINT_SYNC_DECODE_IMAGES);
 
+      // Loop over the canvasList list again and clear out the no longer
+      // needed surface and context to save memeory.
+      for (PRInt32 i = canvasList.Length() - 1; i >= 0 ; i--) {
+        nsICanvasRenderingContextInternal *ctx = canvasList[i]->GetContextAtIndex(0);
+
+        if (ctx)
+          ctx->Reset();
+      }
+
       if (mSelectionHeight >= 0 && selectionY < mSelectionHeight) {
         selectionY += height;
         printedPageNum++;
