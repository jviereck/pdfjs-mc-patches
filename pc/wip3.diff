diff --git a/content/canvas/src/nsCanvasRenderingContext2D.cpp b/content/canvas/src/nsCanvasRenderingContext2D.cpp
--- a/content/canvas/src/nsCanvasRenderingContext2D.cpp
+++ b/content/canvas/src/nsCanvasRenderingContext2D.cpp
@@ -998,16 +998,17 @@ nsCanvasRenderingContext2D::ApplyStyle(S
     mThebes->SetColor(color);
 }
 
 nsresult
 nsCanvasRenderingContext2D::Redraw()
 {
     if (mIsEntireFrameInvalid)
         return NS_OK;
+
     mIsEntireFrameInvalid = true;
 
     if (!mCanvasElement) {
         NS_ASSERTION(mDocShell, "Redraw with no canvas element or docshell!");
         return NS_OK;
     }
 
     nsSVGEffects::InvalidateDirectRenderingObservers(HTMLCanvasElement());
@@ -1016,17 +1017,17 @@ nsCanvasRenderingContext2D::Redraw()
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCanvasRenderingContext2D::Redraw(const gfxRect& r)
 {
     ++mInvalidateCount;
-
+  
     if (mIsEntireFrameInvalid)
         return NS_OK;
 
     if (mPredictManyRedrawCalls ||
         mInvalidateCount > kCanvasMaxInvalidateCount) {
         return Redraw();
     }
 
@@ -1355,17 +1356,17 @@ nsCanvasRenderingContext2D::SetCanvasEle
     mCanvasElement = aCanvasElement;
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCanvasRenderingContext2D::GetCanvas(nsIDOMHTMLCanvasElement **canvas)
 {
-    NS_IF_ADDREF(*canvas = mCanvasElement);
+    *canvas = HTMLCanvasElement()->GetOriginalCanvas();
 
     return NS_OK;
 }
 
 //
 // state
 //
 
@@ -2126,16 +2127,17 @@ nsCanvasRenderingContext2D::ClearRect(fl
     mThebes->Fill();
 
     return RedrawUser(mThebes->GetUserPathExtent());
 }
 
 nsresult
 nsCanvasRenderingContext2D::DrawRect(const gfxRect& rect, Style style)
 {
+    printf("nsCanvasRenderingContext2D::DrawRect(\n");
     if (!EnsureSurface())
         return NS_ERROR_FAILURE;
 
     if (!FloatValidate(rect.X(), rect.Y(), rect.Width(), rect.Height()))
         return NS_OK;
 
     PathAutoSaveRestore pathSR(this);
 
@@ -4188,17 +4190,20 @@ nsCanvasRenderingContext2D::GetCanvasLay
     }
 
     nsRefPtr<CanvasLayer> canvasLayer = aManager->CreateCanvasLayer();
     if (!canvasLayer) {
         NS_WARNING("CreateCanvasLayer returned null!");
         return nsnull;
     }
     CanvasRenderingContext2DUserData *userData = nsnull;
-    if (aBuilder->IsPaintingToWindow()) {
+    printf("=== nsCanvasRenderingContext2D::GetCanvasLayer - IsPaintingToWindow()=%s\n", 
+            aBuilder->IsPaintingToWindow() ? "true" : "false");
+    // if (aBuilder->IsPaintingToWindow()) {
+    if (true) {
       // Make the layer tell us whenever a transaction finishes (including
       // the current transaction), so we can clear our invalidation state and
       // start invalidating again. We need to do this for the layer that is
       // being painted to a window (there shouldn't be more than one at a time,
       // and if there is, flushing the invalidation state more often than
       // necessary is harmless).
 
       // The layer will be destroyed when we tear down the presentation
@@ -4231,15 +4236,16 @@ bool
 nsCanvasRenderingContext2D::ShouldForceInactiveLayer(LayerManager *aManager)
 {
     return !aManager->CanUseCanvasLayerForSize(gfxIntSize(mWidth, mHeight));
 }
 
 void
 nsCanvasRenderingContext2D::MarkContextClean()
 {
+    printf("=== nsCanvasRenderingContext2D::MarkContextClean()\n");
     if (mInvalidateCount > 0) {
         mPredictManyRedrawCalls = mInvalidateCount > kCanvasMaxInvalidateCount;
     }
     mIsEntireFrameInvalid = false;
     mInvalidateCount = 0;
 }
 
diff --git a/content/html/content/public/nsHTMLCanvasElement.h b/content/html/content/public/nsHTMLCanvasElement.h
--- a/content/html/content/public/nsHTMLCanvasElement.h
+++ b/content/html/content/public/nsHTMLCanvasElement.h
@@ -19,16 +19,18 @@
 #include "nsICanvasRenderingContextInternal.h"
 #include "nsICanvasElementExternal.h"
 #include "nsIDOMCanvasRenderingContext2D.h"
 #include "nsLayoutUtils.h"
 
 #include "Layers.h"
 
 class nsIDOMFile;
+class nsCanvasPrintState;
+class nsITimerCallback;
 
 class nsHTMLCanvasElement : public nsGenericHTMLElement,
                             public nsICanvasElementExternal,
                             public nsIDOMHTMLCanvasElement
 {
   typedef mozilla::layers::CanvasLayer CanvasLayer;
   typedef mozilla::layers::LayerManager LayerManager;
 
@@ -163,19 +165,36 @@ protected:
   nsresult MozGetAsFileImpl(const nsAString& aName,
                             const nsAString& aType,
                             nsIDOMFile** aResult);
   nsresult GetContextHelper(const nsAString& aContextId,
                             bool aForceThebes,
                             nsICanvasRenderingContextInternal **aContext);
 
   nsString mCurrentContextId;
+
+  nsCOMPtr<nsIDOMHTMLCanvasElement> mOriginalCanvas;
+  nsCOMPtr<nsIPrintCallback> mPrintCallback;
   nsCOMPtr<nsICanvasRenderingContextInternal> mCurrentContext;
-  
+  nsCOMPtr<nsCanvasPrintState> mPrintState;
 public:
   // Record whether this canvas should be write-only or not.
   // We set this when script paints an image from a different origin.
   // We also transitively set it when script paints a canvas which
   // is itself write-only.
   bool                     mWriteOnly;
+
+  bool mIsPrintCanvas;
+  bool mIsPrintPreview;
+  
+  bool IsPrintCallbackDone();
+  bool IsPrintCallbackAborted();
+
+  bool HandlePrintCallback();
+
+  void CallPrintCallback(nsITimerCallback *aCallback);
+
+  void ResetPrintCallback();
+
+  nsIDOMHTMLCanvasElement* GetOriginalCanvas();
 };
 
 #endif /* nsHTMLCanvasElement_h__ */
diff --git a/content/html/content/src/nsHTMLCanvasElement.cpp b/content/html/content/src/nsHTMLCanvasElement.cpp
--- a/content/html/content/src/nsHTMLCanvasElement.cpp
+++ b/content/html/content/src/nsHTMLCanvasElement.cpp
@@ -21,51 +21,165 @@
 #include "mozilla/Preferences.h"
 #include "mozilla/Telemetry.h"
 
 #include "nsFrameManager.h"
 #include "nsDisplayList.h"
 #include "ImageLayers.h"
 #include "BasicLayers.h"
 #include "imgIEncoder.h"
+#include "nsITimer.h"
+#include "nsAsyncDOMEvent.h"
 
 #include "nsIWritablePropertyBag2.h"
 
+#include "nsIDOMHTMLCanvasElement.h"
+
 #define DEFAULT_CANVAS_WIDTH 300
 #define DEFAULT_CANVAS_HEIGHT 150
 
 using namespace mozilla;
 using namespace mozilla::dom;
 using namespace mozilla::layers;
 
+#define NS_ICANVASPRINTSTATE_IID \
+   {0x8d5fb8a0, 0x7782, 0x11e1, { 0xb0, 0xc4, 0x08, 0x00, 0x20, 0x0c, 0x9a, 0x67 }} 
+
+class nsCanvasPrintState : public nsICanvasPrintState
+{
+public:
+  NS_DECLARE_STATIC_IID_ACCESSOR(NS_ICANVASPRINTSTATE_IID)
+
+
+  nsCanvasPrintState(
+      nsHTMLCanvasElement *aCanvas,
+      nsICanvasRenderingContextInternal *aContext, 
+      nsITimerCallback *aCallback)
+  : mIsDone(false), mIsAborted(false),
+    mCanvas(aCanvas), mContext(aContext), mCallback(aCallback) {
+  }
+
+  NS_IMETHOD GetContext(nsISupports **context)
+  {
+    printf("=== GetContext2\n");
+    NS_ADDREF(*context = mContext);
+    return NS_OK;
+  }
+
+  NS_IMETHOD Done()
+  {
+    printf("CPS::Done\n");
+    Finalize(false);
+    return NS_OK;
+  }
+
+  NS_IMETHOD Abort()
+  {
+    printf("CPS::Abort\n");
+    Finalize(true);
+    (new nsAsyncDOMEvent(
+       mCanvas->GetDocument(), NS_LITERAL_STRING("printCanvasAbort"), true, true)
+    )->RunDOMEventWhenSafe();
+    return NS_OK;
+  }
+
+  void Finalize(bool aAborted)
+  {
+    if (!mIsDone) {
+      mIsDone = true;
+      mIsAborted = aAborted;
+      if (mCallback) {
+        mCallback->Notify(nsnull);
+      }
+      Reset();
+    }
+  }
+
+  void Reset()
+  {
+    printf("=== nsCanvasPrintState::Reset()\n");
+  }
+
+  bool mIsDone;
+  bool mIsAborted;
+
+  // CC
+  NS_DECL_CYCLE_COLLECTING_ISUPPORTS
+  NS_DECL_CYCLE_COLLECTION_CLASS(nsCanvasPrintState)
+private:
+  ~nsCanvasPrintState() 
+  {
+    printf("--- nsCanvasPrintState::Destory\n");
+  }
+
+protected:
+  nsRefPtr<nsHTMLCanvasElement> mCanvas;
+  nsCOMPtr<nsICanvasRenderingContextInternal> mContext;
+  nsCOMPtr<nsITimerCallback> mCallback;
+};
+
+NS_DEFINE_STATIC_IID_ACCESSOR(nsCanvasPrintState, NS_ICANVASPRINTSTATE_IID) 
+
+NS_IMPL_CYCLE_COLLECTING_ADDREF(nsCanvasPrintState)
+NS_IMPL_CYCLE_COLLECTING_RELEASE(nsCanvasPrintState)
+
+DOMCI_DATA(CanvasPrintState, nsCanvasPrintState)
+
+NS_INTERFACE_MAP_BEGIN_CYCLE_COLLECTION(nsCanvasPrintState)
+  NS_INTERFACE_MAP_ENTRY(nsISupports)
+  NS_INTERFACE_MAP_ENTRY(nsICanvasPrintState)
+  NS_DOM_INTERFACE_MAP_ENTRY_CLASSINFO(CanvasPrintState)
+NS_INTERFACE_MAP_END
+
+NS_IMPL_CYCLE_COLLECTION_CLASS(nsCanvasPrintState)
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN(nsCanvasPrintState)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR_AMBIGUOUS(mCanvas, nsIDOMHTMLCanvasElement)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mContext)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mCallback)
+NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
+
+NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN(nsCanvasPrintState)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mCanvas)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mContext)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mCallback)
+NS_IMPL_CYCLE_COLLECTION_UNLINK_END
+// ---------------------------------------------------------------------------
+
 nsGenericHTMLElement*
 NS_NewHTMLCanvasElement(already_AddRefed<nsINodeInfo> aNodeInfo,
                         FromParser aFromParser)
 {
   return new nsHTMLCanvasElement(aNodeInfo);
 }
 
 nsHTMLCanvasElement::nsHTMLCanvasElement(already_AddRefed<nsINodeInfo> aNodeInfo)
-  : nsGenericHTMLElement(aNodeInfo), mWriteOnly(false)
-{
+  : nsGenericHTMLElement(aNodeInfo), 
+    mOriginalCanvas(nsnull), mPrintState(nsnull), mWriteOnly(false),
+    mIsPrintCanvas(false), mIsPrintPreview(false) {
+    printf("=== nsHTMLCanvasElement - Created!\n");
 }
 
 nsHTMLCanvasElement::~nsHTMLCanvasElement()
 {
+  ResetPrintCallback();
 }
 
 NS_IMPL_CYCLE_COLLECTION_CLASS(nsHTMLCanvasElement)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_BEGIN_INHERITED(nsHTMLCanvasElement,
                                                   nsGenericHTMLElement)
   NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mCurrentContext)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mPrintCallback)
+  NS_IMPL_CYCLE_COLLECTION_TRAVERSE_NSCOMPTR(mPrintState)
 NS_IMPL_CYCLE_COLLECTION_TRAVERSE_END
 
 NS_IMPL_CYCLE_COLLECTION_UNLINK_BEGIN_INHERITED(nsHTMLCanvasElement,
                                                 nsGenericHTMLElement)
   NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mCurrentContext)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mPrintCallback)
+  NS_IMPL_CYCLE_COLLECTION_UNLINK_NSCOMPTR(mPrintState)
 NS_IMPL_CYCLE_COLLECTION_UNLINK_END
 
 NS_IMPL_ADDREF_INHERITED(nsHTMLCanvasElement, nsGenericElement)
 NS_IMPL_RELEASE_INHERITED(nsHTMLCanvasElement, nsGenericElement)
 
 DOMCI_NODE_DATA(HTMLCanvasElement, nsHTMLCanvasElement)
 
 NS_INTERFACE_TABLE_HEAD_CYCLE_COLLECTION_INHERITED(nsHTMLCanvasElement)
@@ -115,28 +229,106 @@ nsHTMLCanvasElement::SetAttr(PRInt32 aNa
   {
     rv = UpdateContext();
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
   return rv;
 }
 
+bool
+nsHTMLCanvasElement::HandlePrintCallback()
+{
+  printf("=== HandlePrintCallback\n");
+  // If the canvas is a printCanvas and the printing target is real paper,
+  // then the canvas is setup in nsSimplePageSequence::PrePagePrintNext().
+  if (mPrintState || !mIsPrintCanvas || !mIsPrintPreview) {
+    return true;
+  }
+
+  CallPrintCallback(nsnull);
+  return true;
+}
+
+void
+nsHTMLCanvasElement::CallPrintCallback(nsITimerCallback *aCallback)
+{
+  printf("=== CE::CallPrintCallback\n");
+  // ??? Any ADD_REF magic to be done here ???
+  mPrintState = new nsCanvasPrintState(this, mCurrentContext, aCallback);
+  mPrintCallback->Render(mPrintState);
+}
+
+void
+nsHTMLCanvasElement::ResetPrintCallback()
+{
+  if (mPrintState) {
+    mPrintState->Reset();
+    mPrintState = nsnull;
+  }
+}
+
+bool
+nsHTMLCanvasElement::IsPrintCallbackDone()
+{
+  printf("=== CE:IsPrintCallbackDone\n");
+  if (mPrintState == nsnull) {
+    return true;
+  }
+
+  return mPrintState->mIsDone;
+}
+
+bool
+nsHTMLCanvasElement::IsPrintCallbackAborted()
+{
+  printf("=== CE:IsPrintCallbackAborted\n");
+  if (mPrintState == nsnull) {
+    return false;
+  }
+
+  return mPrintState->mIsAborted;
+}
+
+nsIDOMHTMLCanvasElement*
+nsHTMLCanvasElement::GetOriginalCanvas()
+{
+  if (mOriginalCanvas == nsnull) {
+    return this;
+  } else {
+    return mOriginalCanvas.get();
+  }
+}
+
 nsresult
 nsHTMLCanvasElement::CopyInnerTo(nsGenericElement* aDest) const
 {
   nsresult rv = nsGenericHTMLElement::CopyInnerTo(aDest);
   NS_ENSURE_SUCCESS(rv, rv);
   if (aDest->OwnerDoc()->IsStaticDocument()) {
     nsHTMLCanvasElement* dest = static_cast<nsHTMLCanvasElement*>(aDest);
+    nsHTMLCanvasElement* self = const_cast<nsHTMLCanvasElement*>(this);
+
+    // By default, we assume this canvas will be displayed in PrintPreview.
+    dest->mIsPrintPreview = true;
+    dest->mPrintCallback = self->mPrintCallback;
+    dest->mOriginalCanvas = self;
+
+    // Mark the canvas to be a "PrintCanvas" in case there is a special
+    // rendering callback for printing.
+    if (dest->mPrintCallback) {
+      dest->mIsPrintCanvas = true;
+    }
+
     nsCOMPtr<nsISupports> cxt;
     dest->GetContext(NS_LITERAL_STRING("2d"), JSVAL_VOID, getter_AddRefs(cxt));
     nsCOMPtr<nsIDOMCanvasRenderingContext2D> context2d = do_QueryInterface(cxt);
-    if (context2d) {
-      context2d->DrawImage(const_cast<nsHTMLCanvasElement*>(this),
+    
+    if (context2d && !dest->mIsPrintCanvas) {
+      context2d->DrawImage(self,
                            0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0);
     }
   }
   return rv;
 }
 
 nsChangeHint
 nsHTMLCanvasElement::GetAttributeChangeHint(const nsIAtom* aAttribute,
@@ -210,16 +402,30 @@ nsHTMLCanvasElement::MozFetchAsStream(ns
 
   nsCOMPtr<nsIInputStreamCallback> asyncCallback;
   rv = NS_NewInputStreamReadyEvent(getter_AddRefs(asyncCallback), aCallback, mainThread);
   NS_ENSURE_SUCCESS(rv, rv);
 
   return asyncCallback->OnInputStreamReady(asyncData);
 }
 
+NS_IMETHODIMP
+nsHTMLCanvasElement::SetMozPrintCallback(nsIPrintCallback *aCallback)
+{
+  mPrintCallback = aCallback;
+  return NS_OK;
+}
+
+NS_IMETHODIMP
+nsHTMLCanvasElement::GetMozPrintCallback(nsIPrintCallback** aCallback)
+{
+  NS_IF_ADDREF(*aCallback = mPrintCallback);
+  return NS_OK;
+}
+
 nsresult
 nsHTMLCanvasElement::ExtractData(const nsAString& aType,
                                  const nsAString& aOptions,
                                  nsIInputStream** aStream,
                                  bool& aFellBackToPNG)
 {
   // note that if we don't have a current context, the spec says we're
   // supposed to just return transparent black pixels of the canvas
@@ -466,17 +672,20 @@ nsHTMLCanvasElement::GetContextHelper(co
 
 NS_IMETHODIMP
 nsHTMLCanvasElement::GetContext(const nsAString& aContextId,
                                 const JS::Value& aContextOptions,
                                 nsISupports **aContext)
 {
   nsresult rv;
 
-  bool forceThebes = false;
+  // xxx force thebes if this is a print canvas.
+  // Remove this once the Azure backend has the right now not implemented
+  // functions for the printCanvas usecase ready.
+  bool forceThebes = mIsPrintCanvas;
 
   while (mCurrentContextId.IsEmpty()) {
     rv = GetContextHelper(aContextId, forceThebes, getter_AddRefs(mCurrentContext));
     NS_ENSURE_SUCCESS(rv, rv);
     if (!mCurrentContext) {
       return NS_OK;
     }
 
@@ -641,21 +850,24 @@ void
 nsHTMLCanvasElement::SetWriteOnly()
 {
   mWriteOnly = true;
 }
 
 void
 nsHTMLCanvasElement::InvalidateCanvasContent(const gfxRect* damageRect)
 {
+  printf("nsHTMLCanvasElement:;InvalidateCanvasContent - Entry\n");
   // We don't need to flush anything here; if there's no frame or if
   // we plan to reframe we don't need to invalidate it anyway.
   nsIFrame *frame = GetPrimaryFrame();
-  if (!frame)
+  if (!frame) {
+    printf("nsHTMLCanvasElement:;InvalidateCanvasContent - Early Quit\n");
     return;
+  }
 
   frame->MarkLayersActive(nsChangeHint(0));
 
   nsRect invalRect;
   nsRect contentArea = frame->GetContentRect();
   if (damageRect) {
     nsIntSize size = GetWidthHeight();
     if (size.width != 0 && size.height != 0) {
@@ -674,16 +886,20 @@ nsHTMLCanvasElement::InvalidateCanvasCon
 
       invalRect = invalRect.Intersect(nsRect(nsPoint(0,0), contentArea.Size()));
     }
   } else {
     invalRect = nsRect(nsPoint(0, 0), contentArea.Size());
   }
   invalRect.MoveBy(contentArea.TopLeft() - frame->GetPosition());
 
+  printf("nsHTMLCanvasElement:;InvalidateCanvasContent - Invalidate\n");
+
+  printf("rect: %d,%d,%d,%d\n", invalRect.x, invalRect.y, invalRect.width, invalRect.height);
+
   Layer* layer = frame->InvalidateLayer(invalRect, nsDisplayItem::TYPE_CANVAS);
   if (layer) {
     static_cast<CanvasLayer*>(layer)->Updated();
   }
 }
 
 void
 nsHTMLCanvasElement::InvalidateCanvas()
diff --git a/dom/base/nsDOMClassInfo.cpp b/dom/base/nsDOMClassInfo.cpp
--- a/dom/base/nsDOMClassInfo.cpp
+++ b/dom/base/nsDOMClassInfo.cpp
@@ -1296,16 +1296,18 @@ static nsDOMClassInfoData sClassInfoData
   NS_DEFINE_CLASSINFO_DATA(CanvasGradient, nsDOMGenericSH,
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
   NS_DEFINE_CLASSINFO_DATA(CanvasPattern, nsDOMGenericSH,
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
   NS_DEFINE_CLASSINFO_DATA(TextMetrics, nsDOMGenericSH,
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
   NS_DEFINE_CLASSINFO_DATA(ImageData, nsDOMGenericSH,
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
+  NS_DEFINE_CLASSINFO_DATA(CanvasPrintState, nsDOMGenericSH,
+                           DOM_DEFAULT_SCRIPTABLE_FLAGS)
 
   NS_DEFINE_CLASSINFO_DATA(SmartCardEvent, nsDOMGenericSH,
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
   NS_DEFINE_CLASSINFO_DATA(PageTransitionEvent, nsDOMGenericSH,
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
   NS_DEFINE_CLASSINFO_DATA(WindowUtils, nsDOMGenericSH,
                            DOM_DEFAULT_SCRIPTABLE_FLAGS)
 
@@ -3903,16 +3905,20 @@ nsDOMClassInfo::Init()
   DOM_CLASSINFO_MAP_BEGIN(TextMetrics, nsIDOMTextMetrics)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMTextMetrics)
   DOM_CLASSINFO_MAP_END
 
   DOM_CLASSINFO_MAP_BEGIN(ImageData, nsIDOMImageData)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMImageData)
   DOM_CLASSINFO_MAP_END
 
+  DOM_CLASSINFO_MAP_BEGIN(CanvasPrintState, nsICanvasPrintState)
+    DOM_CLASSINFO_MAP_ENTRY(nsICanvasPrintState)
+  DOM_CLASSINFO_MAP_END
+
   DOM_CLASSINFO_MAP_BEGIN(XSLTProcessor, nsIXSLTProcessor)
     DOM_CLASSINFO_MAP_ENTRY(nsIXSLTProcessor)
     DOM_CLASSINFO_MAP_ENTRY(nsIXSLTProcessorPrivate)
   DOM_CLASSINFO_MAP_END
 
   DOM_CLASSINFO_MAP_BEGIN(XPathEvaluator, nsIDOMXPathEvaluator)
     DOM_CLASSINFO_MAP_ENTRY(nsIDOMXPathEvaluator)
   DOM_CLASSINFO_MAP_END
diff --git a/dom/base/nsDOMClassInfoClasses.h b/dom/base/nsDOMClassInfoClasses.h
--- a/dom/base/nsDOMClassInfoClasses.h
+++ b/dom/base/nsDOMClassInfoClasses.h
@@ -317,17 +317,18 @@ DOMCI_CLASS(SVGZoomEvent)
 
 // Canvas
 DOMCI_CLASS(HTMLCanvasElement)
 DOMCI_CLASS(CanvasRenderingContext2D)
 DOMCI_CLASS(CanvasGradient)
 DOMCI_CLASS(CanvasPattern)
 DOMCI_CLASS(TextMetrics)
 DOMCI_CLASS(ImageData)
-
+DOMCI_CLASS(CanvasPrintState)
+  
 // SmartCard Events
 DOMCI_CLASS(SmartCardEvent)
   
 // PageTransition Events
 DOMCI_CLASS(PageTransitionEvent)
 
 // WindowUtils
 DOMCI_CLASS(WindowUtils)
diff --git a/dom/interfaces/html/nsIDOMHTMLCanvasElement.idl b/dom/interfaces/html/nsIDOMHTMLCanvasElement.idl
--- a/dom/interfaces/html/nsIDOMHTMLCanvasElement.idl
+++ b/dom/interfaces/html/nsIDOMHTMLCanvasElement.idl
@@ -19,16 +19,29 @@
  *
  * @status UNDER_DEVELOPMENT
  */
 
 interface nsIDOMFile;
 interface nsIVariant;
 interface nsIInputStreamCallback;
 
+[scriptable, uuid(8d5fb8a0-7782-11e1-b0c4-0800200c9a67)]
+interface nsICanvasPrintState : nsISupports {
+  readonly attribute nsISupports context;
+
+  void done();
+  void abort();
+};
+
+[scriptable, function, uuid(8d5fb8a0-7782-11e1-b0c4-0800200c9a66)]
+interface nsIPrintCallback : nsISupports {
+  void render(in nsICanvasPrintState ctx);
+};
+
 [scriptable, uuid(5929542B-C68E-48AB-84F9-D9642DA39720)]
 interface nsIDOMHTMLCanvasElement : nsIDOMHTMLElement
 {
   attribute unsigned long width;
   attribute unsigned long height;
   attribute boolean mozOpaque;
 
   nsISupports getContext(in DOMString contextId,
@@ -51,10 +64,12 @@ interface nsIDOMHTMLCanvasElement : nsID
   // A Mozilla-only extension to get a canvas context backed by double-buffered
   // shared memory. Only privileged callers can call this.
   nsISupports MozGetIPCContext(in DOMString contextId);
 
   // A Mozilla-only extension that returns the canvas' image data as a data
   // stream in the desired image format.
   void mozFetchAsStream(in nsIInputStreamCallback callback,
                                         [optional] in DOMString type);
+
+  attribute nsIPrintCallback mozPrintCallback;
 };
 
diff --git a/gfx/layers/Layers.h b/gfx/layers/Layers.h
--- a/gfx/layers/Layers.h
+++ b/gfx/layers/Layers.h
@@ -1312,16 +1312,17 @@ public:
   void Updated() { mDirty = true; }
 
   /**
    * Register a callback to be called at the end of each transaction.
    */
   typedef void (* DidTransactionCallback)(void* aClosureData);
   void SetDidTransactionCallback(DidTransactionCallback aCallback, void* aClosureData)
   {
+    printf("=== CanvasLayer::SetDidTransactionCallback\n");
     mCallback = aCallback;
     mCallbackData = aClosureData;
   }
 
   /**
    * CONSTRUCTION PHASE ONLY
    * Set the filter used to resample this image (if necessary).
    */
@@ -1342,17 +1343,19 @@ public:
         SnapTransform(aTransformToSurface, gfxRect(0, 0, 0, 0), nsnull);
     ComputeEffectiveTransformForMaskLayer(aTransformToSurface);
   }
 
 protected:
   CanvasLayer(LayerManager* aManager, void* aImplData)
     : Layer(aManager, aImplData),
       mCallback(nsnull), mCallbackData(nsnull), mFilter(gfxPattern::FILTER_GOOD),
-      mDirty(false) {}
+      mDirty(false) {
+    printf("=== CanvasLayer::CanvasLayer aka. INIT\n");
+  }
 
   virtual nsACString& PrintInfo(nsACString& aTo, const char* aPrefix);
 
   void FireDidTransactionCallback()
   {
     if (mCallback) {
       mCallback(mCallbackData);
     }
diff --git a/layout/generic/nsHTMLCanvasFrame.cpp b/layout/generic/nsHTMLCanvasFrame.cpp
--- a/layout/generic/nsHTMLCanvasFrame.cpp
+++ b/layout/generic/nsHTMLCanvasFrame.cpp
@@ -256,31 +256,37 @@ already_AddRefed<Layer>
 nsHTMLCanvasFrame::BuildLayer(nsDisplayListBuilder* aBuilder,
                               LayerManager* aManager,
                               nsDisplayItem* aItem)
 {
   nsRect area = GetContentRect() - GetPosition() + aItem->ToReferenceFrame();
   nsHTMLCanvasElement* element = static_cast<nsHTMLCanvasElement*>(GetContent());
   nsIntSize canvasSize = GetCanvasSize();
 
+  if (!element->HandlePrintCallback())
+    return nsnull;
+
   if (canvasSize.width <= 0 || canvasSize.height <= 0 || area.IsEmpty())
     return nsnull;
 
   CanvasLayer* oldLayer = static_cast<CanvasLayer*>
     (aBuilder->LayerBuilder()->GetLeafLayerFor(aBuilder, aManager, aItem));
   nsRefPtr<CanvasLayer> layer = element->GetCanvasLayer(aBuilder, oldLayer, aManager);
   if (!layer)
     return nsnull;
 
   nsPresContext* presContext = PresContext();
   gfxRect r = gfxRect(presContext->AppUnitsToGfxUnits(area.x),
                       presContext->AppUnitsToGfxUnits(area.y),
                       presContext->AppUnitsToGfxUnits(area.width),
                       presContext->AppUnitsToGfxUnits(area.height));
 
+  printf("=== nsHTMLCanvasFrame::BuildLayer r=(%2.2f, %2.2f, %2.2f, %2.2f)\n",
+    r.x, r.y, r.width, r.height);
+
   // Transform the canvas into the right place
   gfxMatrix transform;
   transform.Translate(r.TopLeft());
   transform.Scale(r.Width()/canvasSize.width, r.Height()/canvasSize.height);
   layer->SetTransform(gfx3DMatrix::From2D(transform));
   layer->SetFilter(nsLayoutUtils::GetGraphicsFilterForFrame(this));
   layer->SetVisibleRegion(nsIntRect(0, 0, canvasSize.width, canvasSize.height));
 
diff --git a/layout/generic/nsIPageSequenceFrame.h b/layout/generic/nsIPageSequenceFrame.h
--- a/layout/generic/nsIPageSequenceFrame.h
+++ b/layout/generic/nsIPageSequenceFrame.h
@@ -5,16 +5,17 @@
 #ifndef nsIPageSequenceFrame_h___
 #define nsIPageSequenceFrame_h___
 
 #include "nsQueryFrame.h"
 #include "nsRect.h"
 
 class nsPresContext;
 class nsIPrintSettings;
+class nsITimerCallback;
 
 /**
  * Interface for accessing special capabilities of the page sequence frame.
  *
  * Today all that exists are member functions for printing.
  */
 class nsIPageSequenceFrame : public nsQueryFrame
 {
@@ -33,17 +34,20 @@ public:
    *          NS_ERROR_INVALID_ARG if printing a range of pages (not all pages)
    *            and the start page is greater than the total number of pages
    *          NS_ERROR_FAILURE if there is an error
    */
   NS_IMETHOD StartPrint(nsPresContext*  aPresContext,
                         nsIPrintSettings* aPrintOptions,
                         PRUnichar* aDocTitle,
                         PRUnichar* aDocURL) = 0;
+
+  NS_IMETHOD PrePrintNextPage(nsITimerCallback *aCallback, bool *aDone, bool *aAborted) = 0;
   NS_IMETHOD PrintNextPage() = 0;
+  NS_IMETHOD ResetPrintCanvasList() = 0;
   NS_IMETHOD GetCurrentPageNum(PRInt32* aPageNum) = 0;
   NS_IMETHOD GetNumPages(PRInt32* aNumPages) = 0;
   NS_IMETHOD IsDoingPrintRange(bool* aDoing) = 0;
   NS_IMETHOD GetPrintRange(PRInt32* aFromPage, PRInt32* aToPage) = 0;
 
   NS_IMETHOD DoPageEnd() = 0;
   NS_IMETHOD SetSelectionHeight(nscoord aYOffset, nscoord aHeight) = 0;
 
diff --git a/layout/generic/nsSimplePageSequence.cpp b/layout/generic/nsSimplePageSequence.cpp
--- a/layout/generic/nsSimplePageSequence.cpp
+++ b/layout/generic/nsSimplePageSequence.cpp
@@ -13,16 +13,18 @@
 #include "nsIPrintSettings.h"
 #include "nsPageFrame.h"
 #include "nsStyleConsts.h"
 #include "nsRegion.h"
 #include "nsCSSFrameConstructor.h"
 #include "nsContentUtils.h"
 #include "nsDisplayList.h"
 #include "mozilla/Preferences.h"
+#include "nsHTMLCanvasFrame.h"
+#include "nsHTMLCanvasElement.h"
 
 // DateTime Includes
 #include "nsDateTimeFormatCID.h"
 
 #define OFFSET_NOT_SET -1
 
 // Print Options
 #include "nsIPrintOptions.h"
@@ -77,18 +79,20 @@ NS_NewSimplePageSequenceFrame(nsIPresShe
   return new (aPresShell) nsSimplePageSequenceFrame(aContext);
 }
 
 NS_IMPL_FRAMEARENA_HELPERS(nsSimplePageSequenceFrame)
 
 nsSimplePageSequenceFrame::nsSimplePageSequenceFrame(nsStyleContext* aContext) :
   nsContainerFrame(aContext),
   mTotalPages(-1),
+  mCurrentCanvasListSetup(false),
   mSelectionHeight(-1),
-  mYSelOffset(0)
+  mYSelOffset(0),
+  mCalledBeginPage(false)
 {
   nscoord halfInch = PresContext()->CSSTwipsToAppUnits(NS_INCHES_TO_TWIPS(0.5));
   mMargin.SizeTo(halfInch, halfInch, halfInch, halfInch);
 
   // XXX Unsafe to assume successful allocation
   mPageData = new nsSharedPageData();
   mPageData->mHeadFootFont =
     new nsFont(*PresContext()->GetDefaultFont(kGenericFont_serif,
@@ -482,55 +486,68 @@ nsSimplePageSequenceFrame::StartPrint(ns
 
   if (mTotalPages == -1) {
     mTotalPages = totalPages;
   }
 
   return rv;
 }
 
-NS_IMETHODIMP
-nsSimplePageSequenceFrame::PrintNextPage()
+void GetPrintCanvasElementsInFrame(nsIFrame* aFrame, nsTArray<nsRefPtr<nsHTMLCanvasElement> >* aArr)
 {
-  // Print each specified page
-  // pageNum keeps track of the current page and what pages are printing
-  //
-  // printedPageNum keeps track of the current page number to be printed
-  // Note: When print al the pages or a page range the printed page shows the
-  // actual page number, when printing selection it prints the page number starting
-  // with the first page of the selection. For example if the user has a 
-  // selection that starts on page 2 and ends on page 3, the page numbers when
-  // print are 1 and then two (which is different than printing a page range, where
-  // the page numbers would have been 2 and then 3)
 
-  if (mCurrentPageFrame == nsnull) {
-    return NS_ERROR_FAILURE;
+  for (nsIFrame::ChildListIterator childLists(aFrame);
+    !childLists.IsDone(); childLists.Next()) {
+
+    nsFrameList children = childLists.CurrentList();
+    for (nsFrameList::Enumerator e(children); !e.AtEnd(); e.Next()) {
+      nsIFrame* child = e.get();
+
+      // Check if child is a nsHTMLCanvasFrame.
+      nsHTMLCanvasFrame *canvasFrame = do_QueryFrame(child);
+
+      // If there is a canvasFrame, try to get actual canvas element.
+      if (canvasFrame) {
+        nsHTMLCanvasElement *canvas =
+          nsHTMLCanvasElement::FromContent(canvasFrame->GetContent());
+          // CanvasElementFromContent(canvasFrame->GetContent());
+
+        if (canvas && canvas->mIsPrintCanvas) {
+          aArr->AppendElement(canvas);
+          continue;
+        }
+      }
+      // The current child is not a nsHTMLCanvasFrame OR it is but there is
+      // no nsHTMLCanvasElement on it. Check if children of `child` might
+      // contain a nsHTMLCanvasElement.
+      GetPrintCanvasElementsInFrame(child, aArr);
+    }
   }
+}
+
+void
+nsSimplePageSequenceFrame::DetermineWhetherToPrintPage()
+{
+  // See whether we should print this page
+  mPrintThisPage = true;
 
   bool printEvenPages, printOddPages;
   mPageData->mPrintSettings->GetPrintOptions(nsIPrintSettings::kPrintEvenPages, &printEvenPages);
   mPageData->mPrintSettings->GetPrintOptions(nsIPrintSettings::kPrintOddPages, &printOddPages);
 
-  // Begin printing of the document
-  nsDeviceContext *dc = PresContext()->DeviceContext();
-
-  nsresult rv = NS_OK;
-
-  // See whether we should print this page
-  mPrintThisPage = true;
-
   // If printing a range of pages check whether the page number is in the
   // range of pages to print
   if (mDoingPageRange) {
     if (mPageNum < mFromPageNum) {
       mPrintThisPage = false;
     } else if (mPageNum > mToPageNum) {
       mPageNum++;
       mCurrentPageFrame = nsnull;
-      return NS_OK;
+      mPrintThisPage = false;
+      return;
     } else {
       PRInt32 length = mPageRanges.Length();
     
       // Page ranges are pairs (start, end)
       if (length && (length % 2 == 0)) {
         mPrintThisPage = false;
       
         PRInt32 i;
@@ -553,18 +570,180 @@ nsSimplePageSequenceFrame::PrintNextPage
     if (!printEvenPages) {
       mPrintThisPage = false;  // don't print even numbered page
     }
   }
   
   if (nsIPrintSettings::kRangeSelection == mPrintRangeType) {
     mPrintThisPage = true;
   }
+}
+
+NS_IMETHODIMP
+nsSimplePageSequenceFrame::PrePrintNextPage(nsITimerCallback *aCallback, bool* aDone, bool* aAborted)
+{
+  *aAborted = false;
+  printf("--- SPSF::PrePrintNextPage : ENTER\n");
+  if (mCurrentPageFrame == nsnull) {
+    *aDone = true;
+    return NS_ERROR_FAILURE;
+  }
+  
+  DetermineWhetherToPrintPage();
+  // Nothing to do if the current page doesn't get printed OR rendering to
+  // preview. For preview, the `CallPrintCallback` is called from within the
+  // nsHTMLCanvasElement::HandlePrintCallback.
+  if (!mPrintThisPage || !PresContext()->IsRootPaginatedDocument()) {
+    *aDone = true;
+    return NS_OK;
+  }
+
+  printf("--- SPSF::PrePrintNextPage : CheckIfSetupList\n");
+
+
+  // If the canvasList is null, then generate it and start the render
+  // process for all the canvas.
+  if (!mCurrentCanvasListSetup) {
+    mCurrentCanvasListSetup = true;
+    GetPrintCanvasElementsInFrame(mCurrentPageFrame, &mCurrentCanvasList);
+
+    printf("=== GotCanvasList: %d \n", mCurrentCanvasList.Length()); 
+
+    nsRefPtr<gfxASurface> renderingSurface;
+    if (mCurrentCanvasList.Length() != 0) {
+      nsresult rv = NS_OK;
+
+      // Begin printing of the document
+      nsDeviceContext *dc = PresContext()->DeviceContext();
+      printf("=== Begin Page ===\n");
+      PR_PL(("\n"));
+      PR_PL(("***************** BeginPage *****************\n"));
+      rv = dc->BeginPage();
+      NS_ENSURE_SUCCESS(rv, rv);
+
+      mCalledBeginPage = true;
+      
+      nsRefPtr<nsRenderingContext> renderingContext;
+      dc->CreateRenderingContext(*getter_AddRefs(renderingContext));
+      NS_ENSURE_TRUE(renderingContext, NS_ERROR_OUT_OF_MEMORY);
+
+      renderingSurface =
+          renderingContext->ThebesContext()->CurrentSurface();
+      NS_ENSURE_TRUE(renderingSurface, NS_ERROR_OUT_OF_MEMORY);
+    }
+
+    for (PRInt32 i = mCurrentCanvasList.Length() - 1; i >= 0 ; i--) {
+      nsHTMLCanvasElement *canvas = mCurrentCanvasList[i];
+      nsIntSize size = canvas->GetSize();
+
+      nsRefPtr<gfxASurface> printSurface = renderingSurface->
+         CreateSimilarSurface(
+           gfxASurface::CONTENT_COLOR_ALPHA,
+           size
+         );
+
+      nsICanvasRenderingContextInternal *ctx = canvas->GetContextAtIndex(0);
+
+      if (!ctx)
+        continue;
+
+        // Initialize the context with the new printSurface.
+      ctx->InitializeWithSurface(NULL, printSurface, size.width, size.height);
+
+      // This canvas is not intended for preview. 
+      canvas->mIsPrintPreview = false;
+
+      // Start the rendering process.
+      canvas->CallPrintCallback(aCallback);
+      printf(">>> Context: setup!\n");
+    }
+  }
+
+  PRInt32 doneCounter = 0;
+  for (PRInt32 i = mCurrentCanvasList.Length() - 1; i >= 0 ; i--) {
+    nsHTMLCanvasElement *canvas = mCurrentCanvasList[i];
+
+    if (canvas->IsPrintCallbackAborted()) {
+      *aDone = true;
+      *aAborted = true;
+      printf("!!! nsSimplePageSequenceFrame::PrePrintNextPage(...) - ABORTED!\n");
+      
+      // Reset all print-callback objects. Otherwise they might be able to
+      // call aCallback->Notify again, but the print logic expect this not to
+      // happen.
+      ResetPrintCanvasList();
+      return NS_OK;
+    } else if (canvas->IsPrintCallbackDone()) {
+      doneCounter++;
+    }
+  }
+
+  // If all canvas have finished rendering, return true, otherwise false.
+  *aDone = doneCounter == mCurrentCanvasList.Length();
+
+  return NS_OK;
+}
+
+void
+nsSimplePageSequenceFrame::InvalidateInternal(const nsRect& aDamageRect,
+                                  nscoord aX, nscoord aY, nsIFrame* aForChild,
+                                  PRUint32 aFlags)
+{
+  printf("=== nsSimplePageSequenceFrame:;InvalidateInternal\n");
+  // xxx Invalidate the entire frame as otherwise invalidate of printCanvas
+  // don't work properly. This is hopefully no longer necessary once 539356
+  // lands.
+  nsContainerFrame::InvalidateInternal(
+      nsRect(nsPoint(0,0), GetSize()), 0, 0, aForChild, aFlags); 
+}
+
+NS_IMETHODIMP
+nsSimplePageSequenceFrame::ResetPrintCanvasList()
+{
+  for (PRInt32 i = mCurrentCanvasList.Length() - 1; i >= 0 ; i--) {
+    nsHTMLCanvasElement *canvas = mCurrentCanvasList[i];
+    nsICanvasRenderingContextInternal *ctx = canvas->GetContextAtIndex(0);
+
+    if (ctx)
+      ctx->Reset();
+
+    canvas->ResetPrintCallback();
+  }
+
+  mCurrentCanvasList.Clear();
+  mCurrentCanvasListSetup = false; 
+  return NS_OK;
+} 
+
+NS_IMETHODIMP
+nsSimplePageSequenceFrame::PrintNextPage()
+{
+// Print each specified page
+// pageNum keeps track of the current page and what pages are printing
+//
+// printedPageNum keeps track of the current page number to be printed
+// Note: When print al the pages or a page range the printed page shows the
+// actual page number, when printing selection it prints the page number starting
+// with the first page of the selection. For example if the user has a 
+// selection that starts on page 2 and ends on page 3, the page numbers when
+// print are 1 and then two (which is different than printing a page range, where
+// the page numbers would have been 2 and then 3)
+
+  if (mCurrentPageFrame == nsnull) {
+    return NS_ERROR_FAILURE;
+  }
+
+  nsresult rv = NS_OK;
+
+  DetermineWhetherToPrintPage();
 
   if (mPrintThisPage) {
+    // Begin printing of the document
+    nsDeviceContext *dc = PresContext()->DeviceContext();
+
     // XXX This is temporary fix for printing more than one page of a selection
     // This does a poor man's "dump" pagination (see Bug 89353)
     // It has laid out as one long page and now we are just moving or view up/down 
     // one page at a time and printing the contents of what is exposed by the rect.
     // currently this does not work for IFrames
     // I will soon improve this to work with IFrames 
     bool    continuePrinting = true;
     nscoord width, height;
@@ -581,70 +760,86 @@ nsSimplePageSequenceFrame::PrintNextPage
 
     // cast the frame to be a page frame
     nsPageFrame * pf = static_cast<nsPageFrame*>(mCurrentPageFrame);
     pf->SetPageNumInfo(mPageNum, mTotalPages);
     pf->SetSharedPageData(mPageData);
 
     PRInt32 printedPageNum = 1;
     while (continuePrinting) {
+      printf("=== LOOP:ITER ===\n");
       if (PresContext()->IsRootPaginatedDocument()) {
-        PR_PL(("\n"));
-        PR_PL(("***************** BeginPage *****************\n"));
-        rv = dc->BeginPage();
-        NS_ENSURE_SUCCESS(rv, rv);
+        if (!mCalledBeginPage) {
+          printf("=== Begin Page ===\n");
+          PR_PL(("\n"));
+          PR_PL(("***************** BeginPage *****************\n"));
+          rv = dc->BeginPage();
+          NS_ENSURE_SUCCESS(rv, rv);
+        } else {
+          mCalledBeginPage = false;
+        }
       }
 
       PR_PL(("SeqFr::PrintNextPage -> %p PageNo: %d", pf, mPageNum));
 
       nsRefPtr<nsRenderingContext> renderingContext;
       dc->CreateRenderingContext(*getter_AddRefs(renderingContext));
       NS_ENSURE_TRUE(renderingContext, NS_ERROR_OUT_OF_MEMORY);
 
       nsRect drawingRect(nsPoint(0, 0),
                          mCurrentPageFrame->GetSize());
       nsRegion drawingRegion(drawingRect);
+
+
+      // Replace the underlaying context off all canvas that are "printCanvas".
+      nsRefPtr<gfxASurface> renderingSurface =
+          renderingContext->ThebesContext()->CurrentSurface();
+
       nsLayoutUtils::PaintFrame(renderingContext, mCurrentPageFrame,
                                 drawingRegion, NS_RGBA(0,0,0,0),
                                 nsLayoutUtils::PAINT_SYNC_DECODE_IMAGES);
 
       if (mSelectionHeight >= 0 && selectionY < mSelectionHeight) {
         selectionY += height;
         printedPageNum++;
         pf->SetPageNumInfo(printedPageNum, mTotalPages);
         conFrame->SetPosition(conFrame->GetPosition() + nsPoint(0, -height));
         nsContainerFrame::PositionChildViews(conFrame);
 
         PR_PL(("***************** End Page (PrintNextPage) *****************\n"));
         rv = dc->EndPage();
+        printf("=== End Page ===");
         NS_ENSURE_SUCCESS(rv, rv);
       } else {
         continuePrinting = false;
       }
     }
+    printf("=== LOOP:EXIT ===\n");
   }
   return rv;
 }
 
 NS_IMETHODIMP
 nsSimplePageSequenceFrame::DoPageEnd()
 {
   nsresult rv = NS_OK;
   if (PresContext()->IsRootPaginatedDocument() && mPrintThisPage) {
     PR_PL(("***************** End Page (DoPageEnd) *****************\n"));
     rv = PresContext()->DeviceContext()->EndPage();
     NS_ENSURE_SUCCESS(rv, rv);
   }
 
+  ResetPrintCanvasList();
+
   mPageNum++;
 
   if (mCurrentPageFrame) {
     mCurrentPageFrame = mCurrentPageFrame->GetNextSibling();
   }
-  
+
   return rv;
 }
 
 static void PaintPageSequence(nsIFrame* aFrame, nsRenderingContext* aCtx,
                              const nsRect& aDirtyRect, nsPoint aPt)
 {
   static_cast<nsSimplePageSequenceFrame*>(aFrame)->PaintPageSequence(*aCtx, aDirtyRect, aPt);
 }
diff --git a/layout/generic/nsSimplePageSequence.h b/layout/generic/nsSimplePageSequence.h
--- a/layout/generic/nsSimplePageSequence.h
+++ b/layout/generic/nsSimplePageSequence.h
@@ -5,16 +5,17 @@
 #ifndef nsSimplePageSequence_h___
 #define nsSimplePageSequence_h___
 
 #include "nsIPageSequenceFrame.h"
 #include "nsContainerFrame.h"
 #include "nsIPrintSettings.h"
 #include "nsIPrintOptions.h"
 #include "nsIDateTimeFormat.h"
+#include "nsHTMLCanvasElement.h"
 
 //-----------------------------------------------
 // This class maintains all the data that 
 // is used by all the page frame
 // It lives while the nsSimplePageSequenceFrame lives
 class nsSharedPageData {
 public:
   nsSharedPageData();
@@ -71,17 +72,20 @@ public:
   // For Shrink To Fit
   NS_IMETHOD GetSTFPercent(float& aSTFPercent);
 
   // Async Printing
   NS_IMETHOD StartPrint(nsPresContext*  aPresContext,
                         nsIPrintSettings* aPrintSettings,
                         PRUnichar*        aDocTitle,
                         PRUnichar*        aDocURL);
+
+  NS_IMETHOD PrePrintNextPage(nsITimerCallback *aCallback, bool *aDone, bool *aAborted);
   NS_IMETHOD PrintNextPage();
+  NS_IMETHOD ResetPrintCanvasList();
   NS_IMETHOD GetCurrentPageNum(PRInt32* aPageNum);
   NS_IMETHOD GetNumPages(PRInt32* aNumPages);
   NS_IMETHOD IsDoingPrintRange(bool* aDoing);
   NS_IMETHOD GetPrintRange(PRInt32* aFromPage, PRInt32* aToPage);
   NS_IMETHOD DoPageEnd();
 
   // We must allow Print Preview UI to have a background, no matter what the
   // user's settings
@@ -89,16 +93,19 @@ public:
 
   /**
    * Get the "type" of the frame
    *
    * @see nsGkAtoms::sequenceFrame
    */
   virtual nsIAtom* GetType() const;
   
+  virtual void InvalidateInternal(const nsRect& aDamageRect,
+                                   nscoord aX, nscoord aY, nsIFrame* aForChild,
+                                   PRUint32 aFlags);
 #ifdef NS_DEBUG
   NS_IMETHOD  GetFrameName(nsAString& aResult) const;
 #endif
 
   void PaintPageSequence(nsRenderingContext& aRenderingContext,
                          const nsRect&        aDirtyRect,
                          nsPoint              aPt);
 
@@ -113,38 +120,45 @@ protected:
   void SetPageNumberFormat(PRUnichar * aFormatStr, bool aForPageNumOnly);
 
   // Sets the frame desired size to the size of the viewport, or the given
   // nscoords, whichever is larger. Print scaling is applied in this function.
   void SetDesiredSize(nsHTMLReflowMetrics& aDesiredSize,
                       const nsHTMLReflowState& aReflowState,
                       nscoord aWidth, nscoord aHeight);
 
+  void         DetermineWhetherToPrintPage();
+
   nsMargin mMargin;
 
   // I18N date formatter service which we'll want to cache locally.
   nsCOMPtr<nsIDateTimeFormat> mDateFormatter;
 
   nsSize       mSize;
   nsSharedPageData* mPageData; // data shared by all the nsPageFrames
 
   // Asynch Printing
   nsIFrame *   mCurrentPageFrame;
   PRInt32      mPageNum;
   PRInt32      mTotalPages;
   PRInt32      mPrintRangeType;
   PRInt32      mFromPageNum;
   PRInt32      mToPageNum;
   nsTArray<PRInt32> mPageRanges;
+  nsTArray<nsRefPtr<nsHTMLCanvasElement> > mCurrentCanvasList;
 
   // Selection Printing Info
   nscoord      mSelectionHeight;
   nscoord      mYSelOffset;
 
   // Asynch Printing
   bool mPrintThisPage;
   bool mDoingPageRange;
 
   bool mIsPrintingSelection;
+  
+  bool mCalledBeginPage;
+
+  bool mCurrentCanvasListSetup;
 };
 
 #endif /* nsSimplePageSequence_h___ */
 
diff --git a/layout/printing/nsPagePrintTimer.cpp b/layout/printing/nsPagePrintTimer.cpp
--- a/layout/printing/nsPagePrintTimer.cpp
+++ b/layout/printing/nsPagePrintTimer.cpp
@@ -47,49 +47,64 @@ nsPagePrintTimer::StartTimer(bool aUseDe
         delay = mDelay;
       }
     }
     mTimer->InitWithCallback(this, delay, nsITimer::TYPE_ONE_SHOT);
   }
   return result;
 }
 
+//nsRunnable
+NS_IMETHODIMP
+nsPagePrintTimer::Run() 
+{
+  printf("=== nsPagePrintTimer::Run()\n");
+  bool initNewTimer = true;
+  // Check to see if we are done
+  // inRange will be true if a page is actually printed
+  bool inRange;
+  bool donePrinting;
 
+  printf("--- donePrePrint!\n");
+  // donePrinting will be true if it completed successfully or
+  // if the printing was cancelled
+  donePrinting = mPrintEngine->PrintPage(mPrintObj, inRange);
+  if (donePrinting) {
+    // now clean up print or print the next webshell
+    if (mPrintEngine->DonePrintingPages(mPrintObj, NS_OK)) {
+      initNewTimer = false;
+    }
+  }
+
+  // Note that the Stop() destroys this after the print job finishes
+  // (The PrintEngine stops holding a reference when DonePrintingPages
+  // returns true.)
+  Stop(); 
+  if (initNewTimer) {
+    ++mFiringCount;
+    nsresult result = StartTimer(inRange);
+    if (NS_FAILED(result)) {
+      donePrinting = true;     // had a failure.. we are finished..
+      mPrintEngine->SetIsPrinting(false);
+    }
+  }
+  return NS_OK;
+};
 
 // nsITimerCallback
 NS_IMETHODIMP
 nsPagePrintTimer::Notify(nsITimer *timer)
 {
   if (mDocViewerPrint) {
-    bool initNewTimer = true;
-    // Check to see if we are done
-    // inRange will be true if a page is actually printed
-    bool inRange;
-    // donePrinting will be true if it completed successfully or
-    // if the printing was cancelled
-    bool donePrinting = mPrintEngine->PrintPage(mPrintObj, inRange);
-    if (donePrinting) {
-      // now clean up print or print the next webshell
-      if (mPrintEngine->DonePrintingPages(mPrintObj, NS_OK)) {
-        initNewTimer = false;
-      }
+    bool donePrePrint = mPrintEngine->PrePrintPage();
+
+    if (donePrePrint) {
+      NS_DispatchToMainThread(this);
     }
 
-    // Note that the Stop() destroys this after the print job finishes
-    // (The PrintEngine stops holding a reference when DonePrintingPages
-    // returns true.)
-    Stop(); 
-    if (initNewTimer) {
-      ++mFiringCount;
-      nsresult result = StartTimer(inRange);
-      if (NS_FAILED(result)) {
-        donePrinting = true;     // had a failure.. we are finished..
-        mPrintEngine->SetIsPrinting(false);
-      }
-    }
   }
   return NS_OK;
 }
 
 void 
 nsPagePrintTimer::Init(nsPrintEngine*          aPrintEngine,
                        nsIDocumentViewerPrint* aDocViewerPrint,
                        PRUint32                aDelay)
diff --git a/layout/printing/nsPagePrintTimer.h b/layout/printing/nsPagePrintTimer.h
--- a/layout/printing/nsPagePrintTimer.h
+++ b/layout/printing/nsPagePrintTimer.h
@@ -5,39 +5,43 @@
 #ifndef nsPagePrintTimer_h___
 #define nsPagePrintTimer_h___
 
 // Timer Includes
 #include "nsITimer.h"
 
 #include "nsIDocumentViewerPrint.h"
 #include "nsPrintObject.h"
+#include "nsThreadUtils.h"
 
 class nsPrintEngine;
 
 //---------------------------------------------------
 //-- Page Timer Class
 //---------------------------------------------------
-class nsPagePrintTimer : public nsITimerCallback
+class nsPagePrintTimer : public nsITimerCallback,
+                         public nsRunnable
 {
 public:
 
   NS_DECL_ISUPPORTS
 
   nsPagePrintTimer();
   ~nsPagePrintTimer();
 
   NS_DECL_NSITIMERCALLBACK
 
   void Init(nsPrintEngine*          aPrintEngine,
             nsIDocumentViewerPrint* aDocViewerPrint,
             PRUint32                aDelay);
 
   nsresult Start(nsPrintObject* aPO);
 
+  NS_IMETHOD Run();
+
   void Stop();
 
 private:
   nsresult StartTimer(bool aUseDelay);
 
   nsPrintEngine*             mPrintEngine;
   nsCOMPtr<nsIDocumentViewerPrint> mDocViewerPrint;
   nsCOMPtr<nsITimer>         mTimer;
diff --git a/layout/printing/nsPrintData.cpp b/layout/printing/nsPrintData.cpp
--- a/layout/printing/nsPrintData.cpp
+++ b/layout/printing/nsPrintData.cpp
@@ -56,16 +56,18 @@ nsPrintData::nsPrintData(ePrintDataType 
   if (!mBrandName) {
     mBrandName = ToNewUnicode(NS_LITERAL_STRING("Mozilla Document"));
   }
 
 }
 
 nsPrintData::~nsPrintData()
 {
+  printf("=== nsPrintData::~nsPrintData()\n");
+
   MOZ_COUNT_DTOR(nsPrintData);
   // remove the event listeners
   if (mPPEventListeners) {
     mPPEventListeners->RemoveListeners();
     NS_RELEASE(mPPEventListeners);
   }
 
   // Only Send an OnEndPrinting if we have started printing
diff --git a/layout/printing/nsPrintEngine.cpp b/layout/printing/nsPrintEngine.cpp
--- a/layout/printing/nsPrintEngine.cpp
+++ b/layout/printing/nsPrintEngine.cpp
@@ -2394,16 +2394,64 @@ nsPrintEngine::ElipseLongString(PRUnicha
       nsMemory::Free(aStr);
       aStr = ToNewUnicode(newStr);
     }
   }
 }
 
 //-------------------------------------------------------
 bool
+nsPrintEngine::PrePrintPage()
+{
+  NS_ASSERTION(mPageSeqFrame,  "mPageSeqFrame is null!");
+  NS_ASSERTION(mPrt,           "mPrt is null!");
+
+  // Although these should NEVER be NULL
+  // This is added insurance, to make sure we don't crash in optimized builds
+  if (!mPrt || !mPageSeqFrame) {
+    return true; // means we are done preparing the page.
+  }
+
+  // Check setting to see if someone request it be cancelled
+  bool isCancelled = false;
+  mPrt->mPrintSettings->GetIsCancelled(&isCancelled);
+  if (isCancelled)
+    return true;
+
+  // Ask mPageSeqFrame if the page is ready to be printed.
+  // If the page doesn't get printed at all, the |done| will be |true|.
+  // |aborted| is set to true iff |printState.aborted()| was called on one of
+  // the printCanvas.
+  bool done = false;
+  bool aborted = false;
+  nsresult rv = mPageSeqFrame->PrePrintNextPage(mPagePrintTimer, &done, &aborted);
+  if (NS_FAILED(rv)) {
+    printf("nsPrintEngine::PrePrintPage() - ERROR!\n");
+    // ??? ::PrintPage doesn't set |mPrt->mIsAborted = true| if rv != NS_ERROR_ABORT,
+    // but I don't really understand why this should be the right thing to do?
+    // Shouldn't |mPrt->mIsAborted| set to true all the time if something
+    // wents wrong?
+    if (rv != NS_ERROR_ABORT) {
+      ShowPrintErrorDialog(rv);
+      mPrt->mIsAborted = true;
+    }
+    done = true;
+  }
+  // If the printCallback was aborted, then set the isAborted flag, but don't
+  // show any error message. It's the developer's job to show/design the user
+  // some error message.
+  if (aborted) {
+    printf("nsPrintEngine::PrePrintPage() - ABORTED!\n");
+    mPrt->mIsAborted = true;
+    done = true;
+  }
+  return done;
+}
+
+bool
 nsPrintEngine::PrintPage(nsPrintObject*    aPO,
                          bool&           aInRange)
 {
   NS_ASSERTION(aPO,            "aPO is null!");
   NS_ASSERTION(mPageSeqFrame,  "mPageSeqFrame is null!");
   NS_ASSERTION(mPrt,           "mPrt is null!");
 
   // Although these should NEVER be NULL
@@ -2414,17 +2462,17 @@ nsPrintEngine::PrintPage(nsPrintObject* 
   }
 
   PR_PL(("-----------------------------------\n"));
   PR_PL(("------ In DV::PrintPage PO: %p (%s)\n", aPO, gFrameTypesStr[aPO->mFrameType]));
 
   // Check setting to see if someone request it be cancelled
   bool isCancelled = false;
   mPrt->mPrintSettings->GetIsCancelled(&isCancelled);
-  if (isCancelled)
+  if (isCancelled || mPrt->mIsAborted)
     return true;
 
   PRInt32 pageNum, numPages, endPage;
   mPageSeqFrame->GetCurrentPageNum(&pageNum);
   mPageSeqFrame->GetNumPages(&numPages);
 
   bool donePrinting;
   bool isDoingPrintRange;
@@ -2799,17 +2847,24 @@ nsPrintEngine::IsWindowsInOurSubTree(nsP
 
 //-------------------------------------------------------
 bool
 nsPrintEngine::DonePrintingPages(nsPrintObject* aPO, nsresult aResult)
 {
   //NS_ASSERTION(aPO, "Pointer is null!");
   PR_PL(("****** In DV::DonePrintingPages PO: %p (%s)\n", aPO, aPO?gFrameTypesStr[aPO->mFrameType]:""));
 
-  if (aPO != nsnull) {
+  // If there is a pageSeqFrame, make sure there are no more printCanvas active
+  // that might call |Notify| on the pagePrintTimer after things are cleaned up
+  // and printing was marked as being done.
+  if (mPageSeqFrame) {
+    mPageSeqFrame->ResetPrintCanvasList();
+  }
+
+  if (aPO != nsnull && !mPrt->mIsAborted) {
     aPO->mHasBeenPrinted = true;
     nsresult rv;
     bool didPrint = PrintDocContent(mPrt->mPrintObject, rv);
     if (NS_SUCCEEDED(rv) && didPrint) {
       PR_PL(("****** In DV::DonePrintingPages PO: %p (%s) didPrint:%s (Not Done Printing)\n", aPO, gFrameTypesStr[aPO->mFrameType], PRT_YESNO(didPrint)));
       return false;
     }
   }
diff --git a/layout/printing/nsPrintEngine.h b/layout/printing/nsPrintEngine.h
--- a/layout/printing/nsPrintEngine.h
+++ b/layout/printing/nsPrintEngine.h
@@ -97,16 +97,17 @@ public:
 
   void SetPrintPO(nsPrintObject* aPO, bool aPrint);
 
   void TurnScriptingOn(bool aDoTurnOn);
   bool CheckDocumentForPPCaching();
   void InstallPrintPreviewListener();
 
   // nsIDocumentViewerPrint Printing Methods
+  bool     PrePrintPage();
   bool     PrintPage(nsPrintObject* aPOect, bool& aInRange);
   bool     DonePrintingPages(nsPrintObject* aPO, nsresult aResult);
 
   //---------------------------------------------------------------------
   void BuildDocTree(nsIDocShellTreeNode *      aParentNode,
                     nsTArray<nsPrintObject*> * aDocList,
                     nsPrintObject *            aPO);
   nsresult ReflowDocList(nsPrintObject * aPO, bool aSetPixelScale);
diff --git a/toolkit/components/printing/content/printPreviewBindings.xml b/toolkit/components/printing/content/printPreviewBindings.xml
--- a/toolkit/components/printing/content/printPreviewBindings.xml
+++ b/toolkit/components/printing/content/printPreviewBindings.xml
@@ -191,16 +191,31 @@
 
             // Now do PrintPreview
             PrintUtils.printPreview();
           }
         ]]>
         </body>
       </method>
 
+      <method name="doPageSetup">
+        <body>
+        <![CDATA[
+          var didOK = PrintUtils.showPageSetup();
+          if (didOK) {
+            // the changes that effect the UI
+            this.updateToolbar();
+
+            // Now do PrintPreview
+            PrintUtils.printPreview();
+          }
+        ]]>
+        </body>
+      </method>
+
       <method name="navigate">
         <parameter name="aDirection"/>
         <parameter name="aPageNum"/>
         <parameter name="aHomeOrEnd"/>
         <body>
         <![CDATA[          
           var print = PrintUtils.getPrintPreview();
 
diff --git a/toolkit/components/printing/content/printUtils.js b/toolkit/components/printing/content/printUtils.js
--- a/toolkit/components/printing/content/printUtils.js
+++ b/toolkit/components/printing/content/printUtils.js
@@ -157,16 +157,17 @@ var PrintUtils = {
   },
 
   _closeHandlerPP: null,
   _webProgressPP: null,
   _callback: null,
   _sourceBrowser: null,
   _originalTitle: "",
   _originalURL: "",
+  _exitPrintPreview: null,
 
   // This observer is called once the progress dialog has been "opened"
   _obsPP: 
   {
     observe: function(aSubject, aTopic, aData)
     {
       // delay the print preview to show the content of the progress dialog
       setTimeout(function () { PrintUtils.enterPrintPreview(); }, 0);
@@ -232,32 +233,41 @@ var PrintUtils = {
       this._closeHandlerPP = document.documentElement.getAttribute("onclose");
     else
       this._closeHandlerPP = null;
     document.documentElement.setAttribute("onclose", "PrintUtils.exitPrintPreview(); return false;");
 
     // disable chrome shortcuts...
     window.addEventListener("keypress", this.onKeyPressPP, true);
 
+    // close print preview if a print canvas got aborted.
+    this._exitPrintPreview = this.exitPrintPreview.bind(this);
+    document.documentElement.addEventListener("printCanvasAbort",
+        this.exitPrintPreview, true);
+
     var browser = this._callback.getPrintPreviewBrowser();
     browser.collapsed = false;
     browser.contentWindow.focus();
 
     // on Enter PP Call back
     this._callback.onEnter();
   },
 
   exitPrintPreview: function ()
   {
+    Components.utils.reportError("exitPrintPreview");
+
     window.removeEventListener("keypress", this.onKeyPressPP, true);
 
     // restore the old close handler
     document.documentElement.setAttribute("onclose", this._closeHandlerPP);
     this._closeHandlerPP = null;
 
+    document.documentElement.removeEventListener("printCanvasAbort", this.exitPrintPreview, true);
+
     var webBrowserPrint = this.getPrintPreview();
     webBrowserPrint.exitPrintPreview();
 
     // remove the print preview toolbar
     var printPreviewTB = document.getElementById("print-preview-toolbar");
     this._callback.getNavToolbox().parentNode.removeChild(printPreviewTB);
 
     var fm = Components.classes["@mozilla.org/focus-manager;1"]
@@ -295,8 +305,11 @@ var PrintUtils = {
     }
     // cancel shortkeys
     if (isModif) {
       aEvent.preventDefault();
       aEvent.stopPropagation();
     }
   }
 }
+
+// Make an explicit binding such that addEventListener/removeEventListener work.
+PrintUtils.exitPrintPreview = PrintUtils.exitPrintPreview.bind(PrintUtils);
