# HG changeset patch
# Parent ac968ff4fe413b5078a900363d091cc5aee6e2e6

diff --git a/gfx/thebes/gfxUserFontSet.cpp b/gfx/thebes/gfxUserFontSet.cpp
--- a/gfx/thebes/gfxUserFontSet.cpp
+++ b/gfx/thebes/gfxUserFontSet.cpp
@@ -58,16 +58,17 @@ using namespace mozilla;
 
 #ifdef PR_LOGGING
 PRLogModuleInfo *gfxUserFontSet::sUserFontsLog = PR_NewLogModule("userfonts");
 #endif /* PR_LOGGING */
 
 #define LOG(args) PR_LOG(sUserFontsLog, PR_LOG_DEBUG, args)
 #define LOG_ENABLED() PR_LOG_TEST(sUserFontsLog, PR_LOG_DEBUG)
 
+
 static PRUint64 sFontSetGeneration = LL_INIT(0, 0);
 
 // TODO: support for unicode ranges not yet implemented
 
 gfxProxyFontEntry::gfxProxyFontEntry(const nsTArray<gfxFontFaceSrc>& aFontFaceSrcList,
              gfxMixedFontFamily *aFamily,
              PRUint32 aWeight,
              PRUint32 aStretch,
@@ -117,16 +118,19 @@ gfxUserFontSet::AddFontFace(const nsAStr
                             const nsTArray<gfxFontFaceSrc>& aFontFaceSrcList,
                             PRUint32 aWeight,
                             PRUint32 aStretch,
                             PRUint32 aItalicStyle,
                             const nsTArray<gfxFontFeature>& aFeatureSettings,
                             const nsString& aLanguageOverride,
                             gfxSparseBitSet *aUnicodeRanges)
 {
+    printf("gfxUserFontSet::AddFontFace %s %d\n", 
+      NS_LossyConvertUTF16toASCII(aFamilyName).get(),
+      this);
     gfxProxyFontEntry *proxyEntry = nsnull;
 
     nsAutoString key(aFamilyName);
     ToLowerCase(key);
 
     bool found;
 
     if (aWeight == 0)
@@ -162,16 +166,17 @@ gfxUserFontSet::AddFontFace(const nsAStr
 
     return proxyEntry;
 }
 
 void
 gfxUserFontSet::AddFontFace(const nsAString& aFamilyName,
                             gfxFontEntry     *aFontEntry)
 {
+    printf("gfxUserFontSet::AddFontFace2 %s", NS_LossyConvertUTF16toASCII(aFamilyName).get());
     nsAutoString key(aFamilyName);
     ToLowerCase(key);
 
     bool found;
 
     gfxMixedFontFamily *family = mFontFamilies.GetWeak(key, &found);
     if (!family) {
         family = new gfxMixedFontFamily(aFamilyName);
@@ -456,16 +461,21 @@ bool
 gfxUserFontSet::OnLoadComplete(gfxProxyFontEntry *aProxy,
                                const PRUint8 *aFontData, PRUint32 aLength,
                                nsresult aDownloadStatus)
 {
     // forget about the loader, as we no longer potentially need to cancel it
     // if the entry is obsoleted
     aProxy->mLoader = nsnull;
 
+      
+    printf("gfxUserFontSet::OnLoadComplete %s %d\n", 
+      NS_LossyConvertUTF16toASCII(aProxy->mName).get(),
+      this);
+
     // download successful, make platform font using font data
     if (NS_SUCCEEDED(aDownloadStatus)) {
         gfxFontEntry *fe = LoadFont(aProxy, aFontData, aLength);
         aFontData = nsnull;
 
         if (fe) {
             IncrementGeneration();
             return true;
@@ -496,16 +506,20 @@ gfxUserFontSet::OnLoadComplete(gfxProxyF
 gfxUserFontSet::LoadStatus
 gfxUserFontSet::LoadNext(gfxProxyFontEntry *aProxyEntry)
 {
     PRUint32 numSrc = aProxyEntry->mSrcList.Length();
 
     NS_ASSERTION(aProxyEntry->mSrcIndex < numSrc,
                  "already at the end of the src list for user font");
 
+    printf("gfxUserFontSet::LoadNext %s %d\n", 
+      NS_LossyConvertUTF16toASCII(aProxyEntry->mName).get(),
+      this);
+
     if (aProxyEntry->mLoadingState == gfxProxyFontEntry::NOT_LOADING) {
         aProxyEntry->mLoadingState = gfxProxyFontEntry::LOADING_STARTED;
         aProxyEntry->mUnsupportedFormat = false;
     } else {
         // we were already loading; move to the next source,
         // but don't reset state - if we've already timed out,
         // that counts against the new download
         aProxyEntry->mSrcIndex++;
@@ -557,18 +571,20 @@ gfxUserFontSet::LoadNext(gfxProxyFontEnt
                     PRUint32 bufferLength = 0;
 
                     // sync load font immediately
                     rv = SyncLoadFontData(aProxyEntry, &currSrc, buffer,
                                           bufferLength);
 
                     if (NS_SUCCEEDED(rv) &&
                         LoadFont(aProxyEntry, buffer, bufferLength)) {
+                        printf("gfxUserFOntSet::LoadNext - success\n");
                         return STATUS_LOADED;
                     } else {
+                        printf("gfxUserFOntSet::LoadNext - failed\n");
                         LogMessage(aProxyEntry, "font load failed",
                                    nsIScriptError::errorFlag, rv);
                     }
 
                 } else {
                     // otherwise load font async
                     rv = StartLoad(aProxyEntry, &currSrc);
                     bool loadOK = NS_SUCCEEDED(rv);
@@ -622,16 +638,20 @@ gfxUserFontSet::IncrementGeneration()
     mGeneration = sFontSetGeneration;
 }
 
 
 gfxFontEntry*
 gfxUserFontSet::LoadFont(gfxProxyFontEntry *aProxy,
                          const PRUint8 *aFontData, PRUint32 &aLength)
 {
+    printf("gfxUserFontSet::LoadFont %s %d\n", 
+      NS_LossyConvertUTF16toASCII(aProxy->mFamily->Name()).get(),
+      this);
+
     // if the proxy doesn't belong to a family, we just bail as it won't be
     // accessible/usable anyhow (maybe the font set got modified right as
     // the load was completing?)
     if (!aProxy->Family()) {
         NS_Free(const_cast<PRUint8*>(aFontData));
         return nsnull;
     }
 
diff --git a/layout/style/nsFontFaceLoader.cpp b/layout/style/nsFontFaceLoader.cpp
--- a/layout/style/nsFontFaceLoader.cpp
+++ b/layout/style/nsFontFaceLoader.cpp
@@ -285,31 +285,36 @@ nsFontFaceLoader::CheckLoadAllowed(nsIPr
   nsIScriptSecurityManager *secMan = nsContentUtils::GetSecurityManager();
   rv = secMan->CheckLoadURIWithPrincipal(aSourcePrincipal, aTargetURI,
                                         nsIScriptSecurityManager::STANDARD);
   if (NS_FAILED(rv)) {
     return rv;
   }
 
   // check content policy
-  PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
-  rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_FONT,
-                                 aTargetURI,
-                                 aSourcePrincipal,
-                                 aContext,
-                                 EmptyCString(), // mime type
-                                 nsnull,
-                                 &shouldLoad,
-                                 nsContentUtils::GetContentPolicy(),
-                                 nsContentUtils::GetSecurityManager());
+  nsCAutoString spec;
+  aTargetURI->GetSpec(spec);
 
-  if (NS_FAILED(rv) || NS_CP_REJECTED(shouldLoad)) {
-    return NS_ERROR_CONTENT_BLOCKED;
+  // XXX Workaround: Don't check policy for data:url-fonts.
+  if (spec.Find("data:font") != 0) {
+    PRInt16 shouldLoad = nsIContentPolicy::ACCEPT;
+    rv = NS_CheckContentLoadPolicy(nsIContentPolicy::TYPE_FONT,
+                                   aTargetURI,
+                                   aSourcePrincipal,
+                                   aContext,
+                                   EmptyCString(), // mime type
+                                   nsnull,
+                                   &shouldLoad,
+                                   nsContentUtils::GetContentPolicy(),
+                                   nsContentUtils::GetSecurityManager());
+
+    if (NS_FAILED(rv) || NS_CP_REJECTED(shouldLoad)) {
+      return NS_ERROR_CONTENT_BLOCKED;
+    }
   }
-
   return NS_OK;
 }
 
 nsUserFontSet::nsUserFontSet(nsPresContext *aContext)
   : mPresContext(aContext)
 {
   NS_ASSERTION(mPresContext, "null context passed to nsUserFontSet");
   mLoaders.Init();
