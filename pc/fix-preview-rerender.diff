# HG changeset patch
# Parent f09de9cae7f007f16f8689e861432c4b38d596db

diff --git a/content/canvas/src/nsCanvasRenderingContext2D.cpp b/content/canvas/src/nsCanvasRenderingContext2D.cpp
--- a/content/canvas/src/nsCanvasRenderingContext2D.cpp
+++ b/content/canvas/src/nsCanvasRenderingContext2D.cpp
@@ -625,7 +625,7 @@
     nsresult DrawPath(Style style, gfxRect *dirtyRect = nsnull);
 
     /**
-     * Draws a rectangle in the given style; used by FillRect and StrokeRect.
+     * Draws a rectangle in the given style; used by  = true;FillRect and StrokeRect.
      */
     nsresult DrawRect(const gfxRect& rect, Style style);
 
@@ -1042,6 +1042,7 @@
 nsresult
 nsCanvasRenderingContext2D::Redraw()
 {
+    printf("CRC2d::Redraw\n");
     if (mIsEntireFrameInvalid)
         return NS_OK;
     mIsEntireFrameInvalid = true;
@@ -1053,6 +1054,7 @@
 
     nsSVGEffects::InvalidateDirectRenderingObservers(HTMLCanvasElement());
 
+    printf("CRC2d::Redraw - Done\n");
     HTMLCanvasElement()->InvalidateCanvasContent(nsnull);
 
     return NS_OK;
@@ -1061,6 +1063,7 @@
 NS_IMETHODIMP
 nsCanvasRenderingContext2D::Redraw(const gfxRect& r)
 {
+    printf("CRC2d::Redraw - rect\n");
     ++mInvalidateCount;
 
     if (mIsEntireFrameInvalid)
@@ -1078,6 +1081,7 @@
 
     nsSVGEffects::InvalidateDirectRenderingObservers(HTMLCanvasElement());
 
+    printf("CRC2d::Redraw - rect - done\n");
     HTMLCanvasElement()->InvalidateCanvasContent(&r);
 
     return NS_OK;
@@ -1086,11 +1090,15 @@
 NS_IMETHODIMP
 nsCanvasRenderingContext2D::RedrawUser(const gfxRect& r)
 {
+    /*
     if (mIsEntireFrameInvalid) {
+        printf("CRC2d::RedrawUser - msIsEntireFrameInvalid=true\n");
         ++mInvalidateCount;
         return NS_OK;
     }
-
+    */
+
+    printf("CRC2d::RedrawUser - call Redraw\n");
     return Redraw(mThebes->UserToDevice(r));
 }
 
@@ -2226,6 +2234,7 @@
 nsresult
 nsCanvasRenderingContext2D::DrawRect(const gfxRect& rect, Style style)
 {
+    printf("=== CRC2D::DrawRect\n");
     if (!EnsureSurface())
         return NS_ERROR_FAILURE;
 
@@ -2248,6 +2257,7 @@
 NS_IMETHODIMP
 nsCanvasRenderingContext2D::FillRect(float x, float y, float w, float h)
 {
+    printf("CRC2d - FillRect\n");
     return DrawRect(gfxRect(x, y, w, h), STYLE_FILL);
 }
 
diff --git a/content/html/content/src/nsHTMLCanvasElement.cpp b/content/html/content/src/nsHTMLCanvasElement.cpp
--- a/content/html/content/src/nsHTMLCanvasElement.cpp
+++ b/content/html/content/src/nsHTMLCanvasElement.cpp
@@ -216,15 +216,15 @@
 bool
 nsHTMLCanvasElement::HandlePrintCallback(nsIntSize &size)
 {
-  printf("=== HandlePrintCallback\n");
+  // printf("=== HandlePrintCallback\n");
   // If the canvas is a printCanvas and the printing target is real paper,
   // then the canvas is setup in nsSimplePageSequence::PrePagePrintNext().
   if (!mIsPrintCanvas || !mIsPrintPreview) {
-    printf("=== handleprintcallback:early quit\n");
+    // printf("=== handleprintcallback:early quit\n");
     return true;
   }
 
-  printf("=== HandlePrintCallback:continue\n");
+  // printf("=== HandlePrintCallback:continue\n");
   nsresult rv;
 
   // For print preview, resize the canvas context, such that
@@ -836,8 +836,11 @@
   // We don't need to flush anything here; if there's no frame or if
   // we plan to reframe we don't need to invalidate it anyway.
   nsIFrame *frame = GetPrimaryFrame();
-  if (!frame)
+  printf("=== CE::InvalidateCanvasContent: %s\n", frame? "t" : "f");
+  if (!frame) {
+    printf("=== CE::InvalidateCanvasContent - NO FRAME\n");
     return;
+  }
 
   frame->MarkLayersActive(nsChangeHint(0));
 
