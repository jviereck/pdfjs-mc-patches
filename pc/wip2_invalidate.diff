# HG changeset patch
# Parent 95ce99ef9581e02e1843eab77a9babdb3d17f89b

diff --git a/content/canvas/src/nsCanvasRenderingContext2D.cpp b/content/canvas/src/nsCanvasRenderingContext2D.cpp
--- a/content/canvas/src/nsCanvasRenderingContext2D.cpp
+++ b/content/canvas/src/nsCanvasRenderingContext2D.cpp
@@ -996,18 +996,20 @@ nsCanvasRenderingContext2D::ApplyStyle(S
         color.a *= CurrentState().globalAlpha;
 
     mThebes->SetColor(color);
 }
 
 nsresult
 nsCanvasRenderingContext2D::Redraw()
 {
+    /*
     if (mIsEntireFrameInvalid)
         return NS_OK;
+    */
     mIsEntireFrameInvalid = true;
 
     if (!mCanvasElement) {
         NS_ASSERTION(mDocShell, "Redraw with no canvas element or docshell!");
         return NS_OK;
     }
 
     nsSVGEffects::InvalidateDirectRenderingObservers(HTMLCanvasElement());
@@ -1016,19 +1018,21 @@ nsCanvasRenderingContext2D::Redraw()
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCanvasRenderingContext2D::Redraw(const gfxRect& r)
 {
     ++mInvalidateCount;
-
+  
+    /*
     if (mIsEntireFrameInvalid)
         return NS_OK;
+    */
 
     if (mPredictManyRedrawCalls ||
         mInvalidateCount > kCanvasMaxInvalidateCount) {
         return Redraw();
     }
 
     if (!mCanvasElement) {
         NS_ASSERTION(mDocShell, "Redraw with no canvas element or docshell!");
@@ -1040,20 +1044,22 @@ nsCanvasRenderingContext2D::Redraw(const
     HTMLCanvasElement()->InvalidateCanvasContent(&r);
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCanvasRenderingContext2D::RedrawUser(const gfxRect& r)
 {
+    /*
     if (mIsEntireFrameInvalid) {
         ++mInvalidateCount;
         return NS_OK;
     }
+    */
 
     return Redraw(mThebes->UserToDevice(r));
 }
 
 NS_IMETHODIMP
 nsCanvasRenderingContext2D::SetDimensions(PRInt32 width, PRInt32 height)
 {
     Initialize(NULL, width, height);
diff --git a/content/html/content/src/nsHTMLCanvasElement.cpp b/content/html/content/src/nsHTMLCanvasElement.cpp
--- a/content/html/content/src/nsHTMLCanvasElement.cpp
+++ b/content/html/content/src/nsHTMLCanvasElement.cpp
@@ -217,22 +217,19 @@ nsHTMLCanvasElement::SetAttr(PRInt32 aNa
 
 bool
 nsHTMLCanvasElement::HandlePrintCallback()
 {
   printf("=== HandlePrintCallback\n");
   // If the canvas is a printCanvas and the printing target is real paper,
   // then the canvas is setup in nsSimplePageSequence::PrePagePrintNext().
   if (mIsReadyToPrint || !mIsPrintCanvas || !mIsPrintPreview) {
-    printf("=== handleprintcallback:early quit\n");
     return true;
   }
 
-  printf("=== HandlePrintCallback:continue\n");
-
   mIsReadyToPrint = true;
   CallPrintCallback(nsnull);
   return true;
 }
 
 void
 nsHTMLCanvasElement::CallPrintCallback(nsITimerCallback *aCallback)
 {
@@ -835,21 +832,24 @@ void
 nsHTMLCanvasElement::SetWriteOnly()
 {
   mWriteOnly = true;
 }
 
 void
 nsHTMLCanvasElement::InvalidateCanvasContent(const gfxRect* damageRect)
 {
+  printf("nsHTMLCanvasElement:;InvalidateCanvasContent - Entry\n");
   // We don't need to flush anything here; if there's no frame or if
   // we plan to reframe we don't need to invalidate it anyway.
   nsIFrame *frame = GetPrimaryFrame();
-  if (!frame)
+  if (!frame) {
+    printf("nsHTMLCanvasElement:;InvalidateCanvasContent - Early Quit\n");
     return;
+  }
 
   frame->MarkLayersActive(nsChangeHint(0));
 
   nsRect invalRect;
   nsRect contentArea = frame->GetContentRect();
   if (damageRect) {
     nsIntSize size = GetWidthHeight();
     if (size.width != 0 && size.height != 0) {
@@ -868,16 +868,20 @@ nsHTMLCanvasElement::InvalidateCanvasCon
 
       invalRect = invalRect.Intersect(nsRect(nsPoint(0,0), contentArea.Size()));
     }
   } else {
     invalRect = nsRect(nsPoint(0, 0), contentArea.Size());
   }
   invalRect.MoveBy(contentArea.TopLeft() - frame->GetPosition());
 
+  printf("nsHTMLCanvasElement:;InvalidateCanvasContent - Invalidate\n");
+
+  printf("rect: %d,%d,%d,%d\n", invalRect.x, invalRect.y, invalRect.width, invalRect.height);
+
   Layer* layer = frame->InvalidateLayer(invalRect, nsDisplayItem::TYPE_CANVAS);
   if (layer) {
     static_cast<CanvasLayer*>(layer)->Updated();
   }
 }
 
 void
 nsHTMLCanvasElement::InvalidateCanvas()
diff --git a/gfx/layers/Layers.h b/gfx/layers/Layers.h
--- a/gfx/layers/Layers.h
+++ b/gfx/layers/Layers.h
@@ -1312,16 +1312,17 @@ public:
   void Updated() { mDirty = true; }
 
   /**
    * Register a callback to be called at the end of each transaction.
    */
   typedef void (* DidTransactionCallback)(void* aClosureData);
   void SetDidTransactionCallback(DidTransactionCallback aCallback, void* aClosureData)
   {
+    printf("=== CanvasLayer::SetDidTransactionCallback\n");
     mCallback = aCallback;
     mCallbackData = aClosureData;
   }
 
   /**
    * CONSTRUCTION PHASE ONLY
    * Set the filter used to resample this image (if necessary).
    */
@@ -1342,17 +1343,19 @@ public:
         SnapTransform(aTransformToSurface, gfxRect(0, 0, 0, 0), nsnull);
     ComputeEffectiveTransformForMaskLayer(aTransformToSurface);
   }
 
 protected:
   CanvasLayer(LayerManager* aManager, void* aImplData)
     : Layer(aManager, aImplData),
       mCallback(nsnull), mCallbackData(nsnull), mFilter(gfxPattern::FILTER_GOOD),
-      mDirty(false) {}
+      mDirty(false) {
+    printf("=== CanvasLayer::CanvasLayer aka. INIT\n");
+  }
 
   virtual nsACString& PrintInfo(nsACString& aTo, const char* aPrefix);
 
   void FireDidTransactionCallback()
   {
     if (mCallback) {
       mCallback(mCallbackData);
     }
