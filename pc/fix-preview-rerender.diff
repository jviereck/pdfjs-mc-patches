# HG changeset patch
# Parent de0fa2da8559a5f50513a2f040950dc414b23296

diff --git a/content/canvas/src/nsCanvasRenderingContext2D.cpp b/content/canvas/src/nsCanvasRenderingContext2D.cpp
--- a/content/canvas/src/nsCanvasRenderingContext2D.cpp
+++ b/content/canvas/src/nsCanvasRenderingContext2D.cpp
@@ -615,17 +615,17 @@ protected:
      * any shadow drawing and will use intermediate surfaces as needed.
      *
      * If dirtyRect is given, it will contain the user-space dirty
      * rectangle of the draw operation.
      */
     nsresult DrawPath(Style style, gfxRect *dirtyRect = nsnull);
 
     /**
-     * Draws a rectangle in the given style; used by FillRect and StrokeRect.
+     * Draws a rectangle in the given style; used by  = true;FillRect and StrokeRect.
      */
     nsresult DrawRect(const gfxRect& rect, Style style);
 
     /**
      * Gets the pres shell from either the canvas element or the doc shell
      */
     nsIPresShell *GetPresShell() {
       nsCOMPtr<nsIContent> content = do_QueryObject(mCanvasElement);
@@ -1030,35 +1030,38 @@ nsCanvasRenderingContext2D::ApplyStyle(S
         color.a *= CurrentState().globalAlpha;
 
     mThebes->SetColor(color);
 }
 
 nsresult
 nsCanvasRenderingContext2D::Redraw()
 {
+    printf("CRC2d::Redraw\n");
     if (mIsEntireFrameInvalid)
         return NS_OK;
     mIsEntireFrameInvalid = true;
 
     if (!mCanvasElement) {
         NS_ASSERTION(mDocShell, "Redraw with no canvas element or docshell!");
         return NS_OK;
     }
 
     nsSVGEffects::InvalidateDirectRenderingObservers(HTMLCanvasElement());
 
+    printf("CRC2d::Redraw - Done\n");
     HTMLCanvasElement()->InvalidateCanvasContent(nsnull);
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCanvasRenderingContext2D::Redraw(const gfxRect& r)
 {
+    printf("CRC2d::Redraw - rect\n");
     ++mInvalidateCount;
 
     if (mIsEntireFrameInvalid)
         return NS_OK;
 
     if (mPredictManyRedrawCalls ||
         mInvalidateCount > kCanvasMaxInvalidateCount) {
         return Redraw();
@@ -1066,29 +1069,34 @@ nsCanvasRenderingContext2D::Redraw(const
 
     if (!mCanvasElement) {
         NS_ASSERTION(mDocShell, "Redraw with no canvas element or docshell!");
         return NS_OK;
     }
 
     nsSVGEffects::InvalidateDirectRenderingObservers(HTMLCanvasElement());
 
+    printf("CRC2d::Redraw - rect - done\n");
     HTMLCanvasElement()->InvalidateCanvasContent(&r);
 
     return NS_OK;
 }
 
 NS_IMETHODIMP
 nsCanvasRenderingContext2D::RedrawUser(const gfxRect& r)
 {
+    /*
     if (mIsEntireFrameInvalid) {
+        printf("CRC2d::RedrawUser - msIsEntireFrameInvalid=true\n");
         ++mInvalidateCount;
         return NS_OK;
     }
-
+    */
+
+    printf("CRC2d::RedrawUser - call Redraw\n");
     return Redraw(mThebes->UserToDevice(r));
 }
 
 NS_IMETHODIMP
 nsCanvasRenderingContext2D::SetDimensions(PRInt32 width, PRInt32 height)
 {
     Initialize(NULL, width, height);
     return NS_OK;
@@ -2160,16 +2168,17 @@ nsCanvasRenderingContext2D::ClearRect(fl
     mThebes->Fill();
 
     return RedrawUser(mThebes->GetUserPathExtent());
 }
 
 nsresult
 nsCanvasRenderingContext2D::DrawRect(const gfxRect& rect, Style style)
 {
+    printf("=== CRC2D::DrawRect\n");
     if (!EnsureSurface())
         return NS_ERROR_FAILURE;
 
     if (!FloatValidate(rect.X(), rect.Y(), rect.Width(), rect.Height()))
         return NS_OK;
 
     PathAutoSaveRestore pathSR(this);
 
@@ -2182,16 +2191,17 @@ nsCanvasRenderingContext2D::DrawRect(con
         return rv;
 
     return RedrawUser(dirty);
 }
 
 NS_IMETHODIMP
 nsCanvasRenderingContext2D::FillRect(float x, float y, float w, float h)
 {
+    printf("CRC2d - FillRect\n");
     return DrawRect(gfxRect(x, y, w, h), STYLE_FILL);
 }
 
 NS_IMETHODIMP
 nsCanvasRenderingContext2D::StrokeRect(float x, float y, float w, float h)
 {
     if (w == 0.f && h == 0.f) {
         return NS_OK;
diff --git a/content/html/content/src/nsHTMLCanvasElement.cpp b/content/html/content/src/nsHTMLCanvasElement.cpp
--- a/content/html/content/src/nsHTMLCanvasElement.cpp
+++ b/content/html/content/src/nsHTMLCanvasElement.cpp
@@ -798,18 +798,21 @@ nsHTMLCanvasElement::SetWriteOnly()
 }
 
 void
 nsHTMLCanvasElement::InvalidateCanvasContent(const gfxRect* damageRect)
 {
   // We don't need to flush anything here; if there's no frame or if
   // we plan to reframe we don't need to invalidate it anyway.
   nsIFrame *frame = GetPrimaryFrame();
-  if (!frame)
+  printf("=== CE::InvalidateCanvasContent: %s\n", frame? "t" : "f");
+  if (!frame) {
+    printf("=== CE::InvalidateCanvasContent - NO FRAME\n");
     return;
+  }
 
   frame->MarkLayersActive(nsChangeHint(0));
 
   nsRect invalRect;
   nsRect contentArea = frame->GetContentRect();
   if (damageRect) {
     nsIntSize size = GetWidthHeight();
     if (size.width != 0 && size.height != 0) {
